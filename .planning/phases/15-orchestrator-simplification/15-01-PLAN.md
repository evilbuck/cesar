---
phase: 15-orchestrator-simplification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cesar/orchestrator.py
  - cesar/diarization.py
  - cesar/timestamp_aligner.py
  - cesar/transcriber.py
  - cesar/transcript_formatter.py
autonomous: true

must_haves:
  truths:
    - "timestamp_aligner.py is deleted from codebase"
    - "orchestrator.py uses WhisperXPipeline instead of SpeakerDiarizer + timestamp alignment"
    - "DiarizationError and AuthenticationError exceptions remain importable from cesar.diarization"
    - "Fallback to plain transcription works when diarization fails"
    - "Formatter accepts WhisperXSegment directly without transformation"
  artifacts:
    - path: "cesar/orchestrator.py"
      provides: "Simplified orchestrator using WhisperXPipeline with fallback"
      contains: "WhisperXPipeline"
    - path: "cesar/diarization.py"
      provides: "Exception classes only (SpeakerDiarizer deleted)"
      exports: ["DiarizationError", "AuthenticationError"]
    - path: "cesar/transcript_formatter.py"
      provides: "Formatter with duck-typed segment input"
      contains: "format_timestamp"
  key_links:
    - from: "cesar/orchestrator.py"
      to: "cesar/whisperx_wrapper.py"
      via: "WhisperXPipeline import"
      pattern: "from cesar.whisperx_wrapper import WhisperXPipeline"
    - from: "cesar/orchestrator.py"
      to: "cesar/diarization.py"
      via: "exception import"
      pattern: "from cesar.diarization import DiarizationError"
    - from: "cesar/orchestrator.py"
      to: "cesar/transcriber.py"
      via: "AudioTranscriber for fallback"
      pattern: "from cesar.transcriber import AudioTranscriber"
    - from: "cesar/transcript_formatter.py"
      to: "WhisperXSegment"
      via: "duck-typed segment attributes"
      pattern: "segment\\.start.*segment\\.end.*segment\\.speaker.*segment\\.text"
---

<objective>
Simplify the transcription orchestrator to use WhisperX unified pipeline

Purpose: Replace multi-component pipeline (transcriber + diarizer + timestamp_aligner) with WhisperX which handles transcription, alignment, and diarization internally. Delete obsolete timestamp_aligner.py module. Include fallback to plain transcription when diarization fails.

Output: Simplified orchestrator.py using WhisperXPipeline with AudioTranscriber fallback, diarization.py with only exception classes, timestamp_aligner.py deleted, formatter adapted for WhisperXSegment
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-orchestrator-simplification/15-CONTEXT.md
@.planning/phases/15-orchestrator-simplification/15-RESEARCH.md
@cesar/orchestrator.py
@cesar/whisperx_wrapper.py
@cesar/diarization.py
@cesar/timestamp_aligner.py
@cesar/transcript_formatter.py
@cesar/transcriber.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Slim down diarization.py to exception classes only</name>
  <files>cesar/diarization.py</files>
  <action>
Keep only the exception class definitions (DiarizationError, AuthenticationError). Delete the SpeakerDiarizer class entirely - WhisperXPipeline replaces it.

Also keep SpeakerSegment and DiarizationResult dataclasses for backward compatibility (they may still be useful for type hints or testing).

The module should contain:
1. DiarizationError exception
2. AuthenticationError exception (subclass of DiarizationError)
3. SpeakerSegment dataclass (optional - for compatibility)
4. DiarizationResult dataclass (optional - for compatibility)

Delete: SpeakerDiarizer class and all its methods (~100 lines).
  </action>
  <verify>
```bash
python -c "from cesar.diarization import DiarizationError, AuthenticationError; print('Exceptions importable')"
python -c "from cesar.diarization import SpeakerDiarizer" 2>&1 | grep -q "cannot import" && echo "SpeakerDiarizer correctly removed"
```
  </verify>
  <done>DiarizationError and AuthenticationError importable, SpeakerDiarizer class deleted</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite orchestrator.py to use WhisperXPipeline with AudioTranscriber fallback</name>
  <files>cesar/orchestrator.py</files>
  <action>
Rewrite TranscriptionOrchestrator to use WhisperXPipeline instead of separate transcriber + diarizer + timestamp_aligner. Include fallback to plain transcription using AudioTranscriber when diarization fails (requirement WX-09).

Constructor changes:
- Remove: transcriber parameter (AudioTranscriber) - NO, KEEP IT as optional for fallback
- Remove: diarizer parameter (SpeakerDiarizer)
- Add: pipeline parameter (WhisperXPipeline, optional)
- Keep: formatter parameter (MarkdownTranscriptFormatter, optional)
- Keep: transcriber parameter (AudioTranscriber, optional) - for fallback transcription

New signature:
```python
def __init__(
    self,
    pipeline: Optional[WhisperXPipeline] = None,
    transcriber: Optional[AudioTranscriber] = None,  # For fallback
    formatter: Optional[MarkdownTranscriptFormatter] = None
):
```

orchestrate() method changes:
1. When diarization enabled AND pipeline provided:
   - Call pipeline.transcribe_and_diarize() which returns (segments, speaker_count, duration)
   - Segments are WhisperXSegment which duck-types with AlignedSegment (has start, end, speaker, text)
   - Pass segments directly to formatter (no align_timestamps call needed)

2. When diarization disabled OR pipeline not provided:
   - Use transcriber.transcribe_file() for plain transcription (no speaker labels)
   - If transcriber not provided, raise ValueError("Transcription requires either pipeline or transcriber")

3. Error handling with fallback (WX-09):
   - Catch DiarizationError from pipeline
   - Log explicit partial success message: "Transcription succeeded, diarization failed: {reason}. Falling back to plain transcript."
   - If transcriber available: fall back to transcriber.transcribe_file()
   - If transcriber not available: re-raise the DiarizationError
   - Let AuthenticationError propagate (user must fix HF token)
   - Wrap unknown exceptions in DiarizationError with `raise ... from e`

4. Progress callback:
   - Pass progress_callback to pipeline.transcribe_and_diarize()
   - Scale appropriately (0-90% for pipeline, 90-100% for formatting)

Remove imports:
- from cesar.timestamp_aligner import align_timestamps, TranscriptionSegment, AlignedSegment
- SpeakerDiarizer from diarization import

Add imports:
- from cesar.whisperx_wrapper import WhisperXPipeline, WhisperXSegment

Keep: OrchestrationResult dataclass, FormattingError exception, _save_plain_transcript method
Keep: AudioTranscriber import for fallback functionality
  </action>
  <verify>
```bash
python -c "from cesar.orchestrator import TranscriptionOrchestrator, OrchestrationResult; print('Imports work')"
python -c "
from cesar.orchestrator import TranscriptionOrchestrator
import inspect
sig = inspect.signature(TranscriptionOrchestrator.__init__)
params = list(sig.parameters.keys())
print('Constructor params:', params)
assert 'pipeline' in params, 'Missing pipeline param'
assert 'transcriber' in params, 'Missing transcriber param (needed for fallback)'
assert 'diarizer' not in params, 'Should not have diarizer param'
print('Constructor signature correct')
"
# Verify fallback path exists
python -c "
import ast
with open('cesar/orchestrator.py') as f:
    source = f.read()
assert 'DiarizationError' in source, 'Should catch DiarizationError'
assert 'transcriber' in source, 'Should use transcriber for fallback'
print('Fallback logic present')
"
```
  </verify>
  <done>Orchestrator uses WhisperXPipeline, has AudioTranscriber fallback for WX-09, no longer imports timestamp_aligner or SpeakerDiarizer</done>
</task>

<task type="auto">
  <name>Task 3: Delete timestamp_aligner.py, fix imports, and verify formatter compatibility</name>
  <files>cesar/timestamp_aligner.py, cesar/transcriber.py, cesar/transcript_formatter.py</files>
  <action>
1. DELETE cesar/timestamp_aligner.py entirely

2. Fix cesar/transcriber.py:
   - Remove: `from cesar.timestamp_aligner import TranscriptionSegment`
   - Add TranscriptionSegment dataclass directly in transcriber.py (same definition):
     ```python
     @dataclass
     class TranscriptionSegment:
         """Segment from Whisper transcription."""
         start: float
         end: float
         text: str
     ```
   - Keep using it in transcribe_to_segments() return type

3. Fix cesar/transcript_formatter.py to work with WhisperXSegment directly (CONTEXT decision: "Formatter should adapt to accept WhisperX segment structure directly"):
   - Remove: `from cesar.timestamp_aligner import AlignedSegment, format_timestamp`
   - Move format_timestamp function into transcript_formatter.py (same implementation):
     ```python
     def format_timestamp(seconds: float) -> str:
         """Format seconds as HH:MM:SS or MM:SS."""
         hours = int(seconds // 3600)
         minutes = int((seconds % 3600) // 60)
         secs = int(seconds % 60)
         if hours > 0:
             return f"{hours}:{minutes:02d}:{secs:02d}"
         return f"{minutes}:{secs:02d}"
     ```
   - Update type hints to use duck typing instead of AlignedSegment:
     - Change `List[AlignedSegment]` to `List[Any]` with Protocol or just `List`
     - Add docstring comment: "Accepts any segment with start, end, speaker, text attributes (WhisperXSegment, AlignedSegment, etc.)"
   - Verify formatter accesses only: segment.start, segment.end, segment.speaker, segment.text
     (WhisperXSegment provides all four - confirmed in whisperx_wrapper.py lines 17-32)

4. Add explicit verification that WhisperXSegment is compatible:
   - The formatter uses: segment.start, segment.end, segment.speaker, segment.text
   - WhisperXSegment has: start: float, end: float, speaker: str, text: str
   - This is an exact match - formatter will work without changes to its logic
  </action>
  <verify>
```bash
# Verify timestamp_aligner.py is deleted
test ! -f cesar/timestamp_aligner.py && echo "timestamp_aligner.py deleted"

# Verify transcriber still works
python -c "from cesar.transcriber import AudioTranscriber, TranscriptionSegment; print('Transcriber OK')"

# Verify formatter still works
python -c "from cesar.transcript_formatter import MarkdownTranscriptFormatter, format_timestamp; print('Formatter OK')"

# Verify no dangling imports
python -c "import cesar.orchestrator; import cesar.transcriber; import cesar.transcript_formatter; print('All modules import cleanly')"

# EXPLICIT: Verify formatter works with WhisperXSegment duck-typing
python -c "
from cesar.transcript_formatter import MarkdownTranscriptFormatter
from cesar.whisperx_wrapper import WhisperXSegment

# Create test segment
seg = WhisperXSegment(start=0.0, end=1.5, speaker='SPEAKER_00', text='Hello world')

# Formatter should work with duck-typed segments
formatter = MarkdownTranscriptFormatter(speaker_count=1, duration=10.0)
output = formatter.format([seg])
assert 'Speaker 1' in output, 'Speaker label should be formatted'
assert 'Hello world' in output, 'Text should appear'
print('Formatter works with WhisperXSegment directly')
"
```
  </verify>
  <done>timestamp_aligner.py deleted, TranscriptionSegment moved to transcriber.py, format_timestamp moved to transcript_formatter.py, formatter verified compatible with WhisperXSegment</done>
</task>

</tasks>

<verification>
```bash
# All core modules import without errors
python -c "
import cesar.orchestrator
import cesar.diarization
import cesar.transcriber
import cesar.transcript_formatter
import cesar.whisperx_wrapper
print('All core modules import OK')
"

# Exception classes still available
python -c "
from cesar.diarization import DiarizationError, AuthenticationError
raise DiarizationError('test')
" 2>&1 | grep -q "DiarizationError: test" && echo "Exceptions work"

# timestamp_aligner.py no longer exists
test ! -f cesar/timestamp_aligner.py && echo "timestamp_aligner.py successfully deleted"

# orchestrator uses WhisperXPipeline
grep -q "WhisperXPipeline" cesar/orchestrator.py && echo "Orchestrator uses WhisperXPipeline"
grep -qv "SpeakerDiarizer" cesar/orchestrator.py && echo "Orchestrator no longer uses SpeakerDiarizer"

# Verify fallback wiring (WX-09)
grep -q "transcriber" cesar/orchestrator.py && grep -q "DiarizationError" cesar/orchestrator.py && echo "Fallback transcription wired"

# Verify formatter compatibility with WhisperXSegment
python -c "
from cesar.transcript_formatter import MarkdownTranscriptFormatter
from cesar.whisperx_wrapper import WhisperXSegment
seg = WhisperXSegment(start=0.0, end=2.0, speaker='SPEAKER_01', text='Test')
fmt = MarkdownTranscriptFormatter(speaker_count=2, duration=60.0)
out = fmt.format([seg])
assert 'Speaker 2' in out and 'Test' in out
print('Formatter/WhisperXSegment compatibility verified')
"
```
</verification>

<success_criteria>
- timestamp_aligner.py deleted from codebase
- orchestrator.py constructor accepts pipeline (WhisperXPipeline) and transcriber (AudioTranscriber for fallback)
- DiarizationError and AuthenticationError remain importable from cesar.diarization
- All cesar.* modules import without errors
- No references to deleted timestamp_aligner module remain
- Fallback to plain transcription works when diarization fails (WX-09)
- Formatter accepts WhisperXSegment directly without transformation (verified with test)
</success_criteria>

<output>
After completion, create `.planning/phases/15-orchestrator-simplification/15-01-SUMMARY.md`
</output>
