---
phase: 08-error-handling-docs
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - cesar/api/server.py
  - cesar/cli.py
  - tests/test_server.py
  - tests/test_cli.py
autonomous: true

must_haves:
  truths:
    - "API YouTube errors return JSON with error_type field and appropriate HTTP status"
    - "CLI YouTube errors display user-friendly messages with Rich formatting"
    - "CLI verbose mode shows cleaned underlying cause for errors"
  artifacts:
    - path: "cesar/api/server.py"
      provides: "YouTube exception handler returning structured error responses"
      contains: "exception_handler"
    - path: "cesar/cli.py"
      provides: "Enhanced YouTube error formatting with verbose support"
    - path: "tests/test_server.py"
      provides: "Tests for API error responses with error_type"
    - path: "tests/test_cli.py"
      provides: "Tests for CLI error message formatting"
  key_links:
    - from: "cesar/api/server.py"
      to: "cesar/youtube_handler.py"
      via: "exception handler for YouTubeDownloadError and subclasses"
      pattern: "@app.exception_handler"
    - from: "cesar/cli.py"
      to: "cesar/youtube_handler.py"
      via: "exception handling in transcribe command"
      pattern: "except.*YouTube"
---

<objective>
Wire enhanced YouTube errors through CLI and API interfaces

Purpose: Ensure the granular error types from Plan 01 are properly surfaced to users through both CLI (with Rich formatting) and API (with structured JSON responses).

Output: FastAPI exception handler for YouTube errors returning error_type + message; CLI error formatting with verbose mode support.
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-error-handling-docs/08-CONTEXT.md
@.planning/phases/08-error-handling-docs/08-RESEARCH.md
@.planning/phases/08-error-handling-docs/08-01-SUMMARY.md
@cesar/api/server.py
@cesar/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FastAPI exception handler for YouTube errors</name>
  <files>cesar/api/server.py</files>
  <action>
Add an exception handler for YouTube errors that returns structured JSON responses:

1. Import YouTubeDownloadError (base class) and Request from fastapi:
   from fastapi import Request
   from cesar.youtube_handler import YouTubeDownloadError, check_ffmpeg_available, is_youtube_url

2. Add exception handler after app creation (before routes):

```python
from fastapi.responses import JSONResponse

@app.exception_handler(YouTubeDownloadError)
async def youtube_error_handler(request: Request, exc: YouTubeDownloadError):
    """Handle YouTube errors with structured JSON response.

    Returns error_type and message for programmatic error handling.
    Uses http_status from exception class attributes.
    """
    return JSONResponse(
        status_code=getattr(exc, 'http_status', 400),
        content={
            "error_type": getattr(exc, 'error_type', 'youtube_error'),
            "message": str(exc),
        }
    )
```

This handler catches all YouTubeDownloadError subclasses and returns:
- HTTP status code from exception's http_status attribute
- JSON body with error_type and message fields

Per CONTEXT.md decision: API errors include error_type field for programmatic handling.
  </action>
  <verify>python -c "from cesar.api.server import app; print('Exception handler registered:', 'YouTubeDownloadError' in str(app.exception_handlers))"</verify>
  <done>FastAPI exception handler returns {"error_type": "...", "message": "..."} with appropriate HTTP status codes</done>
</task>

<task type="auto">
  <name>Task 2: Enhance CLI error formatting with verbose support</name>
  <files>cesar/cli.py</files>
  <action>
Enhance CLI error handling to:
1. Display user-friendly error messages with Rich formatting
2. Show cleaned underlying cause in verbose mode

Update imports to include new exception types:
```python
from cesar.youtube_handler import (
    is_youtube_url,
    download_youtube_audio,
    cleanup_youtube_temp_dir,
    YouTubeDownloadError,
    YouTubeURLError,
    YouTubeUnavailableError,
    YouTubeRateLimitError,
    YouTubeAgeRestrictedError,
    YouTubeNetworkError,
    FFmpegNotFoundError,
)
```

Update the exception handling in the transcribe command. Replace the current FFmpegNotFoundError and YouTubeDownloadError handlers with:

```python
except FFmpegNotFoundError as e:
    error_msg = str(e)
    console.print(f"[red]Error:[/red] {error_msg}")
    click.echo(f"Error: {error_msg}", err=True)
    sys.exit(1)
except YouTubeDownloadError as e:
    error_msg = str(e)
    console.print(f"[red]YouTube Error:[/red] {error_msg}")
    click.echo(f"YouTube Error: {error_msg}", err=True)

    # Show cleaned underlying cause in verbose mode
    if verbose and e.__cause__:
        cause = str(e.__cause__).split('\n')[0]  # First line only
        console.print(f"[dim]  Cause: {cause}[/dim]")
        click.echo(f"  Cause: {cause}", err=True)

    sys.exit(1)
```

Per CONTEXT.md decisions:
- Error messages are self-contained (no external links)
- Verbose mode shows first line of __cause__ (not full stack trace)
- No installation hints for FFmpeg (just state it's not found)
  </action>
  <verify>python -c "from cesar.cli import transcribe; print('CLI imports updated successfully')"</verify>
  <done>CLI displays YouTube errors with Rich formatting and shows underlying cause in verbose mode</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for API and CLI error handling</name>
  <files>tests/test_server.py, tests/test_cli.py</files>
  <action>
Add tests for the new error handling behavior.

In tests/test_server.py, add a new test class:

```python
class TestYouTubeErrorHandling(unittest.TestCase):
    """Tests for YouTube error response format."""

    def setUp(self):
        """Set up test client."""
        from fastapi.testclient import TestClient
        from cesar.api.server import app
        self.client = TestClient(app)

    def test_youtube_error_response_format(self):
        """Test that YouTube errors return error_type and message."""
        # Mock a YouTube URL that triggers an error
        with patch('cesar.api.server.is_youtube_url', return_value=True):
            with patch('cesar.youtube_handler.download_youtube_audio') as mock_download:
                from cesar.youtube_handler import YouTubeRateLimitError
                mock_download.side_effect = YouTubeRateLimitError(
                    "YouTube is limiting requests (video: abc123). Try again later."
                )
                # This test verifies the exception handler format
                # Note: The actual endpoint uses file_handler, so we test via transcribe/url
                response = self.client.post(
                    "/transcribe/url",
                    json={"url": "https://youtube.com/watch?v=abc123"}
                )
                # Worker handles YouTube, so this should queue successfully
                # The error format is tested when worker fails
```

Actually, since YouTube URLs are queued for worker processing (not immediate download in the endpoint), test the exception handler directly:

```python
from unittest.mock import patch
from fastapi.testclient import TestClient

class TestYouTubeExceptionHandler(unittest.TestCase):
    """Tests for YouTube exception handler."""

    def test_exception_handler_returns_error_type(self):
        """Verify exception handler returns structured error response."""
        from cesar.youtube_handler import YouTubeRateLimitError
        from cesar.api.server import youtube_error_handler
        import asyncio

        exc = YouTubeRateLimitError("Test rate limit message")
        # Create a mock request
        from unittest.mock import MagicMock
        mock_request = MagicMock()

        # Call handler
        response = asyncio.run(youtube_error_handler(mock_request, exc))

        self.assertEqual(response.status_code, 429)
        import json
        body = json.loads(response.body)
        self.assertEqual(body['error_type'], 'rate_limited')
        self.assertIn('Test rate limit message', body['message'])

    def test_exception_handler_uses_http_status(self):
        """Verify handler uses http_status from exception."""
        from cesar.youtube_handler import YouTubeNetworkError
        from cesar.api.server import youtube_error_handler
        import asyncio
        from unittest.mock import MagicMock

        exc = YouTubeNetworkError("Network timeout")
        mock_request = MagicMock()
        response = asyncio.run(youtube_error_handler(mock_request, exc))

        self.assertEqual(response.status_code, 502)
```

In tests/test_cli.py, add tests for error message formatting:

```python
class TestYouTubeErrorFormatting(unittest.TestCase):
    """Tests for CLI YouTube error message formatting."""

    @patch('cesar.cli.download_youtube_audio')
    @patch('cesar.cli.is_youtube_url', return_value=True)
    def test_youtube_error_displays_message(self, mock_is_yt, mock_download):
        """Test YouTube errors are displayed with user-friendly format."""
        from cesar.youtube_handler import YouTubeUnavailableError
        mock_download.side_effect = YouTubeUnavailableError(
            "Private video (video: xyz789). This video is private."
        )

        runner = CliRunner()
        result = runner.invoke(
            transcribe,
            ['https://youtube.com/watch?v=xyz789', '-o', 'output.txt']
        )

        self.assertEqual(result.exit_code, 1)
        self.assertIn('YouTube Error:', result.output)
        self.assertIn('Private video', result.output)

    @patch('cesar.cli.download_youtube_audio')
    @patch('cesar.cli.is_youtube_url', return_value=True)
    def test_verbose_shows_cause(self, mock_is_yt, mock_download):
        """Test verbose mode shows underlying cause."""
        from cesar.youtube_handler import YouTubeNetworkError
        inner_error = Exception("HTTP Error 500: Internal Server Error")
        outer_error = YouTubeNetworkError("Network error (video: abc123).")
        outer_error.__cause__ = inner_error
        mock_download.side_effect = outer_error

        runner = CliRunner()
        result = runner.invoke(
            transcribe,
            ['https://youtube.com/watch?v=abc123', '-o', 'output.txt', '-v']
        )

        self.assertEqual(result.exit_code, 1)
        self.assertIn('Cause:', result.output)
```

Run: python -m pytest tests/test_server.py tests/test_cli.py -v --tb=short
  </action>
  <verify>python -m pytest tests/test_server.py tests/test_cli.py -v --tb=short -k "YouTube" or python -m pytest tests/ -v --tb=short</verify>
  <done>Tests verify API returns error_type/message JSON and CLI displays formatted errors with verbose cause</done>
</task>

</tasks>

<verification>
1. All tests pass: python -m pytest tests/ -v --tb=short
2. API exception handler returns JSON with error_type and appropriate HTTP status
3. CLI displays user-friendly error messages with Rich formatting
4. CLI verbose mode shows cleaned underlying cause (first line only)
</verification>

<success_criteria>
- [ ] FastAPI has exception handler for YouTubeDownloadError returning {"error_type": "...", "message": "..."}
- [ ] HTTP status codes match exception types (404 for unavailable, 429 for rate limit, 502 for network, etc.)
- [ ] CLI displays YouTube errors with "[red]YouTube Error:[/red]" prefix
- [ ] CLI verbose mode shows "Cause: ..." line with first line of __cause__
- [ ] All project tests pass
- [ ] New tests verify API error format and CLI error display
</success_criteria>

<output>
After completion, create `.planning/phases/08-error-handling-docs/08-02-SUMMARY.md`
</output>
