---
phase: 04-http-api
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - cesar/api/server.py
  - cesar/api/file_handler.py
  - cesar/api/__init__.py
  - tests/test_server.py
autonomous: true

must_haves:
  truths:
    - "POST /transcribe with file upload creates job and returns 202"
    - "POST /transcribe with URL creates job and returns 202"
    - "File too large returns 413"
    - "Invalid file type returns 400"
    - "Failed URL download returns appropriate error"
  artifacts:
    - path: "cesar/api/server.py"
      provides: "POST /transcribe endpoint"
      contains: "@app.post(\"/transcribe\""
    - path: "cesar/api/file_handler.py"
      provides: "File upload and URL download utilities"
      min_lines: 50
    - path: "tests/test_server.py"
      provides: "Tests for POST /transcribe"
      min_lines: 120
  key_links:
    - from: "cesar/api/server.py"
      to: "cesar/api/file_handler.py"
      via: "import"
      pattern: "from cesar\\.api\\.file_handler import"
    - from: "cesar/api/server.py"
      to: "cesar/api/repository.py"
      via: "app.state.repo.create"
      pattern: "repo\\.create"
---

<objective>
Implement POST /transcribe endpoint supporting both file upload and URL reference.

Purpose: Enable clients to submit audio for transcription via file upload (multipart/form-data) or URL reference (JSON body). Returns 202 Accepted with full job object.

Output:
- File handler utilities for upload/download
- POST /transcribe endpoint with file upload support
- POST /transcribe endpoint with URL reference support
- Comprehensive tests for both input modes
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-http-api/04-01-SUMMARY.md
@.planning/phases/04-http-api/04-RESEARCH.md
@cesar/api/server.py
@cesar/api/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file handler utilities</name>
  <files>cesar/api/file_handler.py, cesar/api/__init__.py</files>
  <action>
Create cesar/api/file_handler.py with:

1. Constants:
   - MAX_FILE_SIZE = 100 * 1024 * 1024  # 100 MB
   - ALLOWED_EXTENSIONS = {'.mp3', '.wav', '.m4a', '.ogg', '.flac', '.aac', '.wma', '.webm'}
   - URL_TIMEOUT = 60  # seconds

2. validate_file_extension(filename: str) -> bool:
   - Check if file extension is in ALLOWED_EXTENSIONS
   - Return True if valid, False otherwise

3. async def save_upload_file(file: UploadFile) -> str:
   - Validate file size from file.size if available
   - If file.size and file.size > MAX_FILE_SIZE: raise HTTPException(413, detail)
   - Get extension from filename or default to ".tmp"
   - Validate extension, raise HTTPException(400) if invalid
   - Create temp file with NamedTemporaryFile(delete=False, suffix=ext)
   - Read content and write to temp file
   - Return temp file path
   - On error, raise HTTPException(500, detail)

4. async def download_from_url(url: str) -> str:
   - Use httpx.AsyncClient with timeout=URL_TIMEOUT
   - GET request to URL
   - response.raise_for_status()
   - Get extension from URL path or default to ".mp3"
   - Validate extension, raise HTTPException(400) if invalid
   - Create temp file with mkstemp
   - Write response.content to file
   - Return temp file path
   - Handle httpx.TimeoutException -> HTTPException(408, "URL download timeout")
   - Handle httpx.HTTPStatusError -> HTTPException(400, f"Failed to download: {status}")

Update cesar/api/__init__.py to export relevant utilities if needed.

Use patterns from 04-RESEARCH.md.
  </action>
  <verify>`python -c "from cesar.api.file_handler import save_upload_file, download_from_url, MAX_FILE_SIZE; print(MAX_FILE_SIZE)"` outputs 104857600</verify>
  <done>cesar/api/file_handler.py exists with save_upload_file and download_from_url functions</done>
</task>

<task type="auto">
  <name>Task 2: Add POST /transcribe endpoint for file upload</name>
  <files>cesar/api/server.py</files>
  <action>
Add to cesar/api/server.py:

1. Import UploadFile, File, Form from fastapi
2. Import status from fastapi (for HTTP_202_ACCEPTED)
3. Import save_upload_file from cesar.api.file_handler

4. Create POST /transcribe endpoint for file upload:
   - Path: /transcribe
   - Status code: 202 (HTTP_202_ACCEPTED)
   - Response model: Job
   - Parameters:
     - file: UploadFile (required)
     - model: str = Form(default="base")
   - Docstring: "Upload audio file for transcription."
   - Implementation:
     - tmp_path = await save_upload_file(file)
     - job = Job(audio_path=tmp_path, model_size=model)
     - await app.state.repo.create(job)
     - return job

Note: Since file upload uses multipart/form-data, the model parameter must be Form(), not a regular parameter.
  </action>
  <verify>`python -c "from cesar.api.server import app; print([r.path for r in app.routes if 'transcribe' in r.path])"`</verify>
  <done>POST /transcribe endpoint accepts file upload and returns 202 with Job</done>
</task>

<task type="auto">
  <name>Task 3: Add POST /transcribe/url endpoint for URL reference</name>
  <files>cesar/api/server.py</files>
  <action>
Add to cesar/api/server.py:

1. Import BaseModel from pydantic (or use existing)
2. Import download_from_url from cesar.api.file_handler

3. Create request model:
   class TranscribeURLRequest(BaseModel):
       url: str  # Use str, validate URL format manually or with pydantic HttpUrl
       model: str = "base"

4. Create POST /transcribe/url endpoint:
   - Path: /transcribe/url
   - Status code: 202 (HTTP_202_ACCEPTED)
   - Response model: Job
   - Body: TranscribeURLRequest
   - Docstring: "Download audio from URL and transcribe."
   - Implementation:
     - tmp_path = await download_from_url(request.url)
     - job = Job(audio_path=tmp_path, model_size=request.model)
     - await app.state.repo.create(job)
     - return job

Note: We use /transcribe/url to differentiate from file upload since they use different content types. This matches the design decision in CONTEXT.md about separate content types.
  </action>
  <verify>`python -c "from cesar.api.server import app; print([r.path for r in app.routes if 'transcribe' in r.path])"` shows /transcribe and /transcribe/url</verify>
  <done>POST /transcribe/url endpoint accepts URL and returns 202 with Job</done>
</task>

<task type="auto">
  <name>Task 4: Add tests for transcribe endpoints</name>
  <files>tests/test_server.py</files>
  <action>
Add test cases to tests/test_server.py:

For POST /transcribe (file upload):
- test_transcribe_file_success: Upload valid audio file, returns 202 with job
- test_transcribe_file_too_large: File exceeds 100MB, returns 413
- test_transcribe_file_invalid_extension: .exe file returns 400
- test_transcribe_file_custom_model: model=small is passed correctly

For POST /transcribe/url:
- test_transcribe_url_success: Mock httpx, valid URL returns 202
- test_transcribe_url_timeout: Mock timeout exception, returns 408
- test_transcribe_url_not_found: Mock 404 from URL, returns 400
- test_transcribe_url_invalid_extension: URL to .exe returns 400

Test approach:
- For file upload: Create small test audio file bytes or use io.BytesIO with valid content
- For URL: Mock httpx.AsyncClient to return test responses
- Use pytest-mock or unittest.mock for httpx mocking
  </action>
  <verify>Run `python -m pytest tests/test_server.py -v` - all tests pass</verify>
  <done>8+ new tests covering POST /transcribe and POST /transcribe/url endpoints</done>
</task>

</tasks>

<verification>
1. All tests pass: `python -m pytest tests/test_server.py -v`
2. Both endpoints exist: Check /openapi.json for /transcribe and /transcribe/url
3. File upload works: `curl -X POST -F "file=@test.mp3" http://localhost:8000/transcribe` returns 202
4. URL submission works: `curl -X POST -H "Content-Type: application/json" -d '{"url":"http://example.com/audio.mp3"}' http://localhost:8000/transcribe/url` returns 202
</verification>

<success_criteria>
- POST /transcribe accepts file upload and returns 202
- POST /transcribe/url accepts URL and returns 202
- File size validation (413 on too large)
- File type validation (400 on invalid)
- URL download errors handled appropriately
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-http-api/04-03-SUMMARY.md`
</output>
