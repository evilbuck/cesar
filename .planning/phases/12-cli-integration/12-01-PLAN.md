---
phase: 12-cli-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cesar/cli.py
  - cesar/orchestrator.py
  - tests/test_cli.py
autonomous: true

must_haves:
  truths:
    - "User can enable speaker identification via --diarize flag (default=True)"
    - "User can disable diarization via --no-diarize flag"
    - "CLI shows sequential progress for transcription, diarization, and formatting"
    - "CLI displays speaker count, segment count, and timing breakdown in summary"
    - "Output file has .md extension when diarized, .txt when plain"
    - "User sees warning when .txt extension auto-changed to .md"
  artifacts:
    - path: "cesar/cli.py"
      provides: "--diarize/--no-diarize flag with orchestrator integration"
      contains: "--diarize/--no-diarize"
    - path: "cesar/orchestrator.py"
      provides: "min_speakers and max_speakers parameters in orchestrate()"
      contains: "min_speakers"
    - path: "tests/test_cli.py"
      provides: "Tests for diarization CLI integration"
      contains: "test_diarize"
  key_links:
    - from: "cesar/cli.py"
      to: "cesar/orchestrator.py"
      via: "TranscriptionOrchestrator import and orchestrate() call with min/max_speakers"
      pattern: "orchestrate.*min_speakers.*max_speakers"
    - from: "cesar/orchestrator.py"
      to: "cesar/diarization.py"
      via: "diarizer.diarize() call passes min/max_speakers"
      pattern: "diarize\\(.*min_speakers.*max_speakers"
    - from: "cesar/cli.py"
      to: "cesar/diarization.py"
      via: "SpeakerDiarizer import and instantiation (hf_token only)"
      pattern: "SpeakerDiarizer\\(hf_token"
    - from: "cesar/cli.py"
      to: "cesar/config.py"
      via: "config.diarize and config.hf_token usage"
      pattern: "config\\.diarize|config\\.hf_token"
---

<objective>
Add --diarize/--no-diarize flag to CLI transcribe command with orchestrator integration, multi-step progress display, and detailed summary output.

Purpose: Enable users to get speaker-labeled transcripts via the CLI with full progress feedback and timing statistics.
Output: Updated cli.py with diarization flag, updated orchestrator.py to accept min/max_speakers, progress tracking for all pipeline steps, and comprehensive summary display.
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-cli-integration/12-CONTEXT.md
@.planning/phases/12-cli-integration/12-RESEARCH.md
@.planning/phases/11-orchestration-&-formatting/11-02-SUMMARY.md

# Source files
@cesar/cli.py
@cesar/orchestrator.py
@cesar/diarization.py
@cesar/config.py
@cesar/utils.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add min/max_speakers support to orchestrator</name>
  <files>cesar/orchestrator.py</files>
  <action>
Update the `orchestrate()` method to accept and pass through min_speakers and max_speakers parameters to the diarizer.

**IMPORTANT:** The SpeakerDiarizer constructor only accepts `hf_token` and `model_name`. The min/max_speakers are passed to the `diarize()` method, not the constructor. This task adds the passthrough in the orchestrator.

1. **Update orchestrate() method signature** (around line 89) to add min_speakers and max_speakers:

   ```python
   def orchestrate(
       self,
       audio_path: Path,
       output_path: Path,
       enable_diarization: bool = True,
       keep_intermediate: bool = False,
       progress_callback: Optional[Callable[[str, float], None]] = None,
       min_speakers: Optional[int] = None,
       max_speakers: Optional[int] = None
   ) -> OrchestrationResult:
   ```

2. **Update docstring** to document the new parameters:

   Add to Args section:
   ```
           min_speakers: Minimum expected speakers (passed to diarizer)
           max_speakers: Maximum expected speakers (passed to diarizer)
   ```

3. **Update diarizer.diarize() call** (around line 157) to pass the speaker count parameters:

   Change from:
   ```python
   diarization_result = self.diarizer.diarize(
       str(audio_path),
       progress_callback=lambda msg: progress_callback(
           "Detecting speakers...", 75.0
       ) if progress_callback else None
   )
   ```

   To:
   ```python
   diarization_result = self.diarizer.diarize(
       str(audio_path),
       min_speakers=min_speakers,
       max_speakers=max_speakers,
       progress_callback=lambda msg: progress_callback(
           "Detecting speakers...", 75.0
       ) if progress_callback else None
   )
   ```

This allows the CLI to pass config values through orchestrate() to the diarizer without changing SpeakerDiarizer's constructor.
  </action>
  <verify>
Run: `python -c "from cesar.orchestrator import TranscriptionOrchestrator; import inspect; sig = inspect.signature(TranscriptionOrchestrator.orchestrate); print('min_speakers' in str(sig) and 'max_speakers' in str(sig))"`
Expected: True
  </verify>
  <done>
- orchestrate() accepts min_speakers and max_speakers parameters
- Parameters passed through to diarizer.diarize() call
- Docstring updated with new parameters
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --diarize flag and orchestrator integration</name>
  <files>cesar/cli.py</files>
  <action>
Modify the `transcribe` command to support speaker diarization:

1. **Add --diarize/--no-diarize flag:**
   ```python
   @click.option(
       '--diarize/--no-diarize',
       default=True,
       show_default=True,
       help='Enable speaker identification (disable with --no-diarize)'
   )
   ```
   Note: Long flags only, no short `-d` form (per CONTEXT.md)

2. **Add imports at top of file:**
   ```python
   from cesar.orchestrator import TranscriptionOrchestrator, OrchestrationResult
   from cesar.diarization import SpeakerDiarizer, DiarizationError
   ```

3. **Add helper function for HF token resolution:**
   ```python
   def get_hf_token(config: CesarConfig) -> Optional[str]:
       """Get HuggingFace token from config or environment.

       Priority: config file > HF_TOKEN env var > None (cached)
       """
       import os
       if config.hf_token:
           return config.hf_token
       return os.environ.get('HF_TOKEN')
   ```

4. **Add helper function for output extension validation:**
   ```python
   def validate_output_extension(output_path: Path, diarize: bool, quiet: bool = False) -> Path:
       """Validate and correct output file extension based on diarization mode.

       Args:
           output_path: User-provided output path
           diarize: Whether diarization is enabled
           quiet: Whether to suppress warnings

       Returns:
           Corrected output path with appropriate extension (.md or .txt)
       """
       expected_ext = '.md' if diarize else '.txt'
       current_ext = output_path.suffix.lower()

       if current_ext != expected_ext:
           corrected_path = output_path.with_suffix(expected_ext)
           if not quiet:
               if diarize and current_ext == '.txt':
                   console.print(
                       f"[yellow]Note: Changed output to {expected_ext} "
                       f"for speaker-labeled transcript[/yellow]"
                   )
               elif not diarize and current_ext == '.md':
                   console.print(
                       f"[yellow]Note: Changed output to {expected_ext} "
                       f"for plain transcript[/yellow]"
                   )
           logger.info(f"Auto-corrected extension: {current_ext} -> {expected_ext}")
           return corrected_path
       return output_path
   ```

5. **Modify transcribe command signature** to include diarize parameter:
   ```python
   def transcribe(ctx, input_source, output, model, device, compute_type,
                  batch_size, num_workers, verbose, quiet, max_duration,
                  start_time, end_time, diarize):
   ```

6. **Replace existing transcription logic** (after model loading, around line 346) with orchestrator integration:

   The key change is: when diarize=True, use TranscriptionOrchestrator instead of direct transcriber.transcribe_file() call.

   ```python
   # Validate output extension based on diarization mode
   output = validate_output_extension(output, diarize, quiet)

   # Validate output path
   transcriber.validate_output_path(str(output))
   if not quiet:
       console.print(f"[green]Output path validated:[/green] {output}")

   # Create diarizer if diarization enabled and token available
   diarizer = None
   if diarize:
       hf_token = get_hf_token(config)
       if hf_token or Path.home().joinpath('.cache/huggingface/token').exists():
           # SpeakerDiarizer only accepts hf_token (and optional model_name)
           # min/max_speakers are passed to orchestrate(), not constructor
           diarizer = SpeakerDiarizer(hf_token=hf_token)
       else:
           if not quiet:
               console.print(
                   "[yellow]Note: Diarization enabled but no HuggingFace token found. "
                   "Set HF_TOKEN env var or add hf_token to config file.[/yellow]"
               )

   # Set up progress tracking
   progress_tracker = ProgressTracker(show_progress=not quiet)

   # Start transcription
   if not quiet:
       console.print(f"\n[bold]Loading Whisper model '{model}'...[/bold]")

   transcription_start_time = time.time()

   with progress_tracker:
       if diarize and diarizer is not None:
           # Use orchestrator for diarized transcription
           orchestrator = TranscriptionOrchestrator(
               transcriber=transcriber,
               diarizer=diarizer
           )

           # Pass min/max_speakers from config to orchestrate()
           result = orchestrator.orchestrate(
               audio_path=input_file,
               output_path=output,
               enable_diarization=True,
               min_speakers=config.min_speakers,
               max_speakers=config.max_speakers,
               progress_callback=lambda step, pct: progress_tracker.update_step(step, pct) if not quiet else None
           )

           # Show results with diarization info
           show_diarization_summary(result, verbose, quiet)
       else:
           # Use direct transcription (existing logic)
           result = transcriber.transcribe_file(
               str(input_file),
               str(output),
               progress_callback=progress_tracker.update if not quiet else None,
               max_duration_minutes=max_duration,
               start_time_seconds=start_time,
               end_time_seconds=end_time
           )

           # Show results (existing logic)
           if not quiet:
               console.print(f"\n[bold green]Transcription completed![/bold green]")
               console.print(f"  Language: [cyan]{result['language']}[/cyan] (probability: {result['language_probability']:.2f})")
               console.print(f"  Audio duration: [blue]{format_time(result['audio_duration'])}[/blue]")
               console.print(f"  Processing time: [blue]{format_time(result['processing_time'])}[/blue]")
               console.print(f"  Speed ratio: [yellow]{result['speed_ratio']:.1f}x[/yellow] faster than real-time")
               console.print(f"  Total segments: [cyan]{result['segment_count']}[/cyan]")
               console.print(f"  Output saved to: [green]{result['output_path']}[/green]")
           else:
               console.print(f"Transcription completed: {result['output_path']}")
   ```

Important: Keep existing error handling, YouTube download logic, and cleanup logic unchanged. The orchestrator integration only replaces the transcription-to-output section.

**CRITICAL:** SpeakerDiarizer constructor only accepts `hf_token` and `model_name`. Do NOT pass min_speakers or max_speakers to the constructor. Pass them to `orchestrator.orchestrate()` instead, which forwards them to `diarizer.diarize()`.
  </action>
  <verify>
Run: `python -c "from cesar.cli import transcribe; print('Import OK')"`
Run: `python transcribe.py --help` to verify --diarize/--no-diarize flags appear in help text
  </verify>
  <done>
- `--diarize/--no-diarize` flag visible in `cesar transcribe --help`
- Default shown as True in help text
- TranscriptionOrchestrator imported and used when diarize=True
- SpeakerDiarizer created with hf_token only (NOT min/max_speakers)
- min_speakers and max_speakers passed to orchestrate() call
- Output extension validation working (.md for diarized, .txt for plain)
  </done>
</task>

<task type="auto">
  <name>Task 3: Multi-step progress and summary display</name>
  <files>cesar/cli.py, tests/test_cli.py</files>
  <action>
1. **Extend ProgressTracker class** to support step name updates:

   ```python
   class ProgressTracker:
       """Track and display transcription progress with multi-step support."""

       def __init__(self, show_progress: bool = True):
           self.show_progress = show_progress
           self.progress = None
           self.task_id = None
           self.last_update = time.time()
           self.current_step = "Transcribing..."

       def __enter__(self):
           if self.show_progress:
               self.progress = Progress(
                   SpinnerColumn(),
                   TextColumn("[progress.description]{task.description}"),
                   BarColumn(),
                   TaskProgressColumn(),
                   TimeElapsedColumn(),
                   TimeRemainingColumn(),
                   console=console
               )
               self.progress.__enter__()
               self.task_id = self.progress.add_task(self.current_step, total=100)
           return self

       def __exit__(self, exc_type, exc_val, exc_tb):
           if self.progress:
               self.progress.__exit__(exc_type, exc_val, exc_tb)

       def update(self, progress_percentage: float, segment_count: int, elapsed_time: float):
           """Update progress display (legacy callback for direct transcription)."""
           if self.progress and self.task_id is not None:
               current_time = time.time()
               if current_time - self.last_update >= 0.5:
                   self.progress.update(
                       self.task_id,
                       completed=progress_percentage,
                       description=f"Transcribing... ({segment_count} segments)"
                   )
                   self.last_update = current_time

       def update_step(self, step_name: str, percentage: float):
           """Update progress with step name and overall percentage (0-100).

           Args:
               step_name: Current step name ("Transcribing...", "Identifying speakers...", "Formatting...")
               percentage: Overall progress percentage (0-100)
           """
           if self.progress and self.task_id is not None:
               current_time = time.time()
               if current_time - self.last_update >= 0.5:
                   self.progress.update(
                       self.task_id,
                       completed=percentage,
                       description=step_name
                   )
                   self.last_update = current_time
                   self.current_step = step_name
   ```

2. **Add show_diarization_summary function:**

   ```python
   def show_diarization_summary(result: OrchestrationResult, verbose: bool, quiet: bool):
       """Display transcription summary with diarization details.

       Args:
           result: OrchestrationResult from orchestrator
           verbose: Whether to show per-speaker breakdown
           quiet: Whether to suppress non-essential output
       """
       if quiet:
           # Minimal output
           console.print(f"Transcription completed: {result.output_path}")
           return

       console.print(f"\n[bold green]Transcription completed![/bold green]")

       # Main summary line
       if result.diarization_succeeded:
           console.print(
               f"  {result.speakers_detected} speaker{'s' if result.speakers_detected != 1 else ''}, "
               f"{format_time(result.audio_duration)} duration"
           )
       else:
           console.print(f"  {format_time(result.audio_duration)} duration")
           console.print("[yellow]  (Speaker detection unavailable)[/yellow]")

       # Timing breakdown
       console.print(f"  Transcription: [blue]{format_time(result.transcription_time)}[/blue]")
       if result.diarization_time is not None:
           console.print(f"  Diarization: [blue]{format_time(result.diarization_time)}[/blue]")
       console.print(f"  Total: [blue]{format_time(result.total_processing_time)}[/blue]")
       console.print(f"  Speed ratio: [yellow]{result.speed_ratio:.1f}x[/yellow] faster than real-time")

       # Verbose: per-speaker stats (deferred - OrchestrationResult doesn't have this yet)
       # if verbose and result.diarization_succeeded:
       #     console.print("\n[bold]Per-speaker breakdown:[/bold]")
       #     # Would need speaker_stats from result

       console.print(f"  Output saved to: [green]{result.output_path}[/green]")
   ```

3. **Add CLI tests** for diarization flag:

   Add to tests/test_cli.py:

   ```python
   def test_diarize_flag_default_true(self):
       """Test that --diarize flag defaults to True in help text."""
       runner = CliRunner()
       result = runner.invoke(cli, ['transcribe', '--help'])
       self.assertEqual(result.exit_code, 0)
       self.assertIn('--diarize', result.output)
       self.assertIn('--no-diarize', result.output)
       # Default should be shown as True
       self.assertIn('default: True', result.output.lower())

   def test_no_diarize_flag_accepted(self):
       """Test that --no-diarize flag is recognized."""
       # Just verify the flag is accepted in argument parsing
       # (actual transcription test requires audio file)
       runner = CliRunner()
       # Invoke with --help after --no-diarize to verify flag is parsed
       result = runner.invoke(cli, ['transcribe', '--no-diarize', '--help'])
       self.assertEqual(result.exit_code, 0)

   def test_output_extension_validation_md_for_diarize(self):
       """Test that output gets .md extension when diarize=True."""
       from cesar.cli import validate_output_extension
       from pathlib import Path

       output = Path('/tmp/transcript.txt')
       corrected = validate_output_extension(output, diarize=True, quiet=True)
       self.assertEqual(corrected.suffix, '.md')

   def test_output_extension_validation_txt_for_no_diarize(self):
       """Test that output gets .txt extension when diarize=False."""
       from cesar.cli import validate_output_extension
       from pathlib import Path

       output = Path('/tmp/transcript.md')
       corrected = validate_output_extension(output, diarize=False, quiet=True)
       self.assertEqual(corrected.suffix, '.txt')

   def test_output_extension_no_change_when_correct(self):
       """Test that correct extensions are not changed."""
       from cesar.cli import validate_output_extension
       from pathlib import Path

       # .md with diarize=True should stay .md
       output = Path('/tmp/transcript.md')
       corrected = validate_output_extension(output, diarize=True, quiet=True)
       self.assertEqual(corrected, output)

       # .txt with diarize=False should stay .txt
       output = Path('/tmp/transcript.txt')
       corrected = validate_output_extension(output, diarize=False, quiet=True)
       self.assertEqual(corrected, output)
   ```

4. **Verify imports** work correctly in test file - add any missing imports at top of test file if needed.
  </action>
  <verify>
Run: `python -m pytest tests/test_cli.py -v -k "diarize or extension"` to verify new tests pass
Run: `python -m pytest tests/test_cli.py -v` to verify all CLI tests still pass
  </verify>
  <done>
- ProgressTracker.update_step() method exists and updates step name
- show_diarization_summary() function displays speaker count and timing
- CLI tests for --diarize flag pass
- CLI tests for extension validation pass
- All existing CLI tests still pass
  </done>
</task>

</tasks>

<verification>
1. `python transcribe.py --help` shows `--diarize/--no-diarize` flags with `[default: True]`
2. `python -c "from cesar.orchestrator import TranscriptionOrchestrator; import inspect; print(inspect.signature(TranscriptionOrchestrator.orchestrate))"` shows min_speakers and max_speakers params
3. `python -m pytest tests/test_cli.py -v` - all tests pass
4. `python -m pytest tests/ -v` - full test suite passes (no regressions)
5. Manual test (if HF token available): `python transcribe.py assets/testing-file/short-sample.mp3 -o /tmp/test.md` produces speaker-labeled output
</verification>

<success_criteria>
- [ ] --diarize/--no-diarize flags appear in CLI help with default True
- [ ] TranscriptionOrchestrator.orchestrate() accepts min_speakers and max_speakers
- [ ] orchestrate() passes min/max_speakers to diarizer.diarize()
- [ ] SpeakerDiarizer created with hf_token only (NOT min/max_speakers in constructor)
- [ ] CLI passes config.min_speakers and config.max_speakers to orchestrate()
- [ ] Output extension auto-corrected with user warning
- [ ] Multi-step progress shows "Transcribing...", "Identifying speakers...", "Formatting..."
- [ ] Summary displays speaker count, timing breakdown
- [ ] All tests pass including new diarization CLI tests
</success_criteria>

<output>
After completion, create `.planning/phases/12-cli-integration/12-01-SUMMARY.md`
</output>
