---
phase: 07-interface-integration
plan: 03
type: execute
wave: 1
depends_on: ["07-01", "07-02"]
files_modified:
  - cesar/api/server.py
  - cesar/api/worker.py
  - tests/test_server.py
  - tests/test_worker.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "API job status endpoint reports download phase with progress percentage"
    - "User can POST /transcribe/url with YouTube URL and job processes successfully with correct status flow"
    - "Job transitions from DOWNLOADING (0%) to DOWNLOADING (100%) to PROCESSING to COMPLETED"
  artifacts:
    - path: "cesar/api/server.py"
      provides: "YouTube URL detection and DOWNLOADING status initialization"
      contains: "JobStatus.DOWNLOADING"
    - path: "cesar/api/worker.py"
      provides: "YouTube download handling and progress updates"
      contains: "download_progress"
  key_links:
    - from: "cesar/api/server.py"
      to: "Job.status"
      via: "DOWNLOADING initialization for YouTube"
      pattern: "status=JobStatus.DOWNLOADING"
    - from: "cesar/api/worker.py"
      to: "Job.download_progress"
      via: "field update during download"
      pattern: "download_progress"
    - from: "cesar/api/worker.py"
      to: "JobStatus.DOWNLOADING"
      via: "status detection and transition"
      pattern: "JobStatus.DOWNLOADING"
---

<objective>
Close verification gaps for YouTube API job status tracking.

Purpose: The DOWNLOADING status and download_progress field exist in the Job model but are never used. This plan wires them into the server and worker so API users can track YouTube download phase separately from transcription.

Output:
- Server initializes YouTube jobs with DOWNLOADING status and download_progress=0
- Worker detects DOWNLOADING jobs and handles YouTube download phase
- Worker updates download_progress during download (0 -> 100)
- Worker transitions from DOWNLOADING to PROCESSING after download
- Full unit test coverage for new behavior
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-interface-integration/07-VERIFICATION.md
@.planning/phases/07-interface-integration/07-02-SUMMARY.md
@cesar/api/models.py
@cesar/api/server.py
@cesar/api/worker.py
@cesar/youtube_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server YouTube URL detection and DOWNLOADING initialization</name>
  <files>cesar/api/server.py, tests/test_server.py</files>
  <action>
Modify the `/transcribe/url` endpoint in server.py to detect YouTube URLs and initialize jobs differently:

1. Import `is_youtube_url` from `cesar.youtube_handler`
2. Before calling `download_from_url()`, check if `is_youtube_url(request.url)`:
   - If YouTube: Create Job with `status=JobStatus.DOWNLOADING`, `download_progress=0`, store URL in `audio_path` (worker will download)
   - If NOT YouTube: Current behavior (download first, then create Job with QUEUED status)

Key insight: For YouTube URLs, we DON'T download in the endpoint anymore. We store the URL and let the worker handle download + transcription. This allows progress tracking.

Code structure in transcribe_from_url():
```python
if is_youtube_url(request.url):
    # YouTube: Create job with DOWNLOADING status, let worker handle download
    job = Job(
        audio_path=request.url,  # Store URL, not file path
        model_size=request.model,
        status=JobStatus.DOWNLOADING,
        download_progress=0,
    )
    await app.state.repo.create(job)
    return job
else:
    # Regular URL: Download first, then queue
    tmp_path = await download_from_url(request.url)
    job = Job(audio_path=tmp_path, model_size=request.model)
    await app.state.repo.create(job)
    return job
```

Add tests in test_server.py:
- test_transcribe_url_youtube_creates_downloading_status: POST YouTube URL returns job with status=DOWNLOADING, download_progress=0
- test_transcribe_url_regular_creates_queued_status: POST regular URL returns job with status=QUEUED, download_progress=None (existing behavior)
  </action>
  <verify>
Run tests: `python -m pytest tests/test_server.py -v`
All tests pass including new YouTube status tests.
  </verify>
  <done>
- YouTube URL POST returns Job with status=DOWNLOADING and download_progress=0
- Regular URL POST returns Job with status=QUEUED and download_progress=None
- Tests verify both paths
  </done>
</task>

<task type="auto">
  <name>Task 2: Worker YouTube download handling with progress updates</name>
  <files>cesar/api/worker.py, tests/test_worker.py</files>
  <action>
Modify the BackgroundWorker to handle YouTube downloads (jobs with DOWNLOADING status):

1. Import youtube_handler functions:
```python
from cesar.youtube_handler import (
    is_youtube_url,
    download_youtube_audio,
    YouTubeDownloadError,
    FFmpegNotFoundError,
)
```

2. Modify `run()` to poll for DOWNLOADING jobs as well as QUEUED jobs:
   - Call `repository.get_next_queued()` first (existing)
   - If no QUEUED job, call `repository.get_next_downloading()` (new method needed? Or modify get_next_queued to handle both)

   Alternative approach: Modify `get_next_queued()` in repository to return jobs with status QUEUED OR DOWNLOADING. This keeps worker simpler.

3. Modify `_process_job()` to detect DOWNLOADING status:
```python
async def _process_job(self, job) -> None:
    self._current_job_id = job.id

    try:
        # Handle YouTube download phase
        if job.status == JobStatus.DOWNLOADING:
            # Update progress to 0 (starting download)
            job.download_progress = 0
            job.started_at = datetime.utcnow()
            await self.repository.update(job)

            # Download YouTube audio (blocking, run in thread pool)
            try:
                audio_path = await asyncio.to_thread(
                    download_youtube_audio,
                    job.audio_path  # Contains the URL
                )
                # Update progress to 100 (download complete)
                job.download_progress = 100
                job.audio_path = str(audio_path)  # Replace URL with file path
                job.status = JobStatus.PROCESSING
                await self.repository.update(job)
            except (YouTubeDownloadError, FFmpegNotFoundError) as e:
                job.status = JobStatus.ERROR
                job.completed_at = datetime.utcnow()
                job.error_message = str(e)
                await self.repository.update(job)
                return
        else:
            # Regular job - update to PROCESSING
            job.status = JobStatus.PROCESSING
            job.started_at = datetime.utcnow()
            await self.repository.update(job)

        # Run transcription (existing logic)
        result = await asyncio.to_thread(...)
        ...
```

4. Update repository.get_next_queued() to return jobs with DOWNLOADING or QUEUED status:
   - Modify the SQL query to: `WHERE status IN ('queued', 'downloading') ORDER BY created_at ASC LIMIT 1`
   - Or create a separate method `get_next_pending()` that handles both

Add tests in test_worker.py:
- test_worker_processes_downloading_job: Create job with DOWNLOADING status and YouTube URL, verify worker downloads, updates progress, transitions to PROCESSING, then COMPLETED
- test_worker_downloading_error_sets_error_status: Create DOWNLOADING job, mock download to fail, verify ERROR status with message
- test_worker_queued_job_unchanged: Verify existing QUEUED job behavior still works (regression test)
  </action>
  <verify>
Run tests: `python -m pytest tests/test_worker.py -v`
All tests pass including new YouTube download handling tests.
Run full suite: `python -m pytest tests/ -v` to ensure no regressions.
  </verify>
  <done>
- Worker detects DOWNLOADING status jobs and handles YouTube download
- download_progress updated: 0 at start, 100 after download
- Status transitions: DOWNLOADING -> PROCESSING -> COMPLETED
- YouTube download errors result in ERROR status with message
- All existing worker tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Update repository to fetch DOWNLOADING jobs</name>
  <files>cesar/api/repository.py, tests/test_repository.py</files>
  <action>
Modify JobRepository.get_next_queued() to also return DOWNLOADING jobs:

1. Update the SQL query in get_next_queued():
```python
async def get_next_queued(self) -> Optional[Job]:
    """Get the next job that needs processing (QUEUED or DOWNLOADING status).

    Returns jobs in FIFO order by created_at timestamp.
    """
    async with aiosqlite.connect(self.db_path) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM jobs WHERE status IN (?, ?) ORDER BY created_at ASC LIMIT 1",
            (JobStatus.QUEUED.value, JobStatus.DOWNLOADING.value)
        ) as cursor:
            row = await cursor.fetchone()
            if row:
                return Job(**dict(row))
            return None
```

2. Add test in test_repository.py:
- test_get_next_queued_returns_downloading: Create a DOWNLOADING job and verify get_next_queued() returns it
- test_get_next_queued_prefers_downloading_over_queued: Create both DOWNLOADING and QUEUED jobs with DOWNLOADING earlier, verify DOWNLOADING returned first (FIFO by created_at)
  </action>
  <verify>
Run tests: `python -m pytest tests/test_repository.py -v`
All repository tests pass including new DOWNLOADING status tests.
  </verify>
  <done>
- get_next_queued() returns jobs with DOWNLOADING or QUEUED status
- FIFO order maintained by created_at
- Tests verify DOWNLOADING jobs are returned
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit tests pass:**
   ```bash
   python -m pytest tests/ -v
   ```
   All tests pass including new gap closure tests.

2. **Integration verification:**
   - POST YouTube URL to /transcribe/url
   - Response has status=DOWNLOADING, download_progress=0
   - GET /jobs/{id} shows status progression: DOWNLOADING -> PROCESSING -> COMPLETED
   - download_progress field shows 0 initially, then 100 after download

3. **Key links verified:**
   - server.py sets JobStatus.DOWNLOADING for YouTube URLs
   - worker.py detects DOWNLOADING status and handles download
   - worker.py updates download_progress (0 -> 100)
   - worker.py transitions DOWNLOADING -> PROCESSING -> COMPLETED
</verification>

<success_criteria>
1. POST /transcribe/url with YouTube URL returns Job with status=DOWNLOADING and download_progress=0
2. Worker processes DOWNLOADING jobs by downloading YouTube audio first
3. Job.download_progress updates from 0 to 100 during download phase
4. Job status transitions: DOWNLOADING -> PROCESSING -> COMPLETED
5. Download errors set status=ERROR with descriptive message
6. All unit tests pass (existing + new)
7. Regular URL handling unchanged (QUEUED status, no download_progress)
</success_criteria>

<output>
After completion, create `.planning/phases/07-interface-integration/07-03-SUMMARY.md`
</output>
