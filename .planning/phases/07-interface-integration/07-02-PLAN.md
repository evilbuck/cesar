---
phase: 07-interface-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cesar/api/file_handler.py
  - cesar/api/models.py
  - cesar/api/server.py
  - tests/test_file_handler.py
  - tests/test_server.py
  - tests/test_models.py
autonomous: true

must_haves:
  truths:
    - "User can POST /transcribe/url with YouTube URL and job processes successfully"
    - "API job status includes downloading phase with distinct status"
    - "API job status includes download_progress field (0-100) for YouTube jobs"
    - "GET /health endpoint reports FFmpeg and YouTube support availability"
  artifacts:
    - path: "cesar/api/models.py"
      provides: "DOWNLOADING status in JobStatus enum and download_progress field"
      contains: "DOWNLOADING|download_progress"
    - path: "cesar/api/file_handler.py"
      provides: "YouTube URL detection and routing to youtube_handler"
      contains: "is_youtube_url|download_youtube_audio"
    - path: "cesar/api/server.py"
      provides: "Health endpoint with YouTube capability reporting"
      contains: "ffmpeg|youtube"
  key_links:
    - from: "cesar/api/file_handler.py"
      to: "cesar/youtube_handler.py"
      via: "import and function call"
      pattern: "from cesar.youtube_handler import"
    - from: "cesar/api/server.py"
      to: "cesar/youtube_handler.py"
      via: "import for health check"
      pattern: "check_ffmpeg_available"
---

<objective>
Add YouTube URL support to the API with status tracking and health reporting

Purpose: Enable users to POST YouTube URLs to /transcribe/url and get job with download phase visibility
Output: API routes YouTube URLs through youtube_handler, reports DOWNLOADING status, and health endpoint shows YouTube capability
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-core-youtube-module/06-01-SUMMARY.md
@cesar/api/file_handler.py
@cesar/api/models.py
@cesar/api/server.py
@cesar/youtube_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DOWNLOADING status, download_progress field, and update file_handler</name>
  <files>cesar/api/models.py, cesar/api/file_handler.py</files>
  <action>
1. In `cesar/api/models.py`, add DOWNLOADING status to JobStatus enum:
   ```python
   class JobStatus(str, Enum):
       """Job lifecycle states.

       Flow: queued -> downloading -> processing -> completed | error
       Note: downloading only applies to YouTube URLs
       """

       QUEUED = "queued"
       DOWNLOADING = "downloading"  # New: YouTube audio extraction
       PROCESSING = "processing"
       COMPLETED = "completed"
       ERROR = "error"
   ```

2. In `cesar/api/models.py`, add download_progress field to Job model:
   ```python
   # In Job class, add after error_message field:

   # Download progress (for YouTube jobs)
   download_progress: Optional[int] = Field(
       default=None,
       ge=0,
       le=100,
       description="Download progress percentage (0-100) for YouTube jobs. None for non-YouTube jobs."
   )
   ```

   Note: download_progress semantics:
   - None: Non-YouTube jobs (regular file uploads)
   - 0: YouTube job created, download starting (status=DOWNLOADING)
   - 100: Download complete, ready for transcription (status transitions to QUEUED/PROCESSING)

   This provides basic progress indication without requiring complex real-time progress hooks.
   The route handler in server.py will need to:
   1. Create job with status=DOWNLOADING and download_progress=0 for YouTube URLs
   2. Perform download
   3. Update job with downloaded file path, status=QUEUED, download_progress=100

3. In `cesar/api/file_handler.py`, add YouTube handling to `download_from_url()`:

   First, add imports at top:
   ```python
   from cesar.youtube_handler import (
       is_youtube_url,
       download_youtube_audio,
       YouTubeDownloadError,
       FFmpegNotFoundError,
   )
   ```

   Then modify `download_from_url()` to detect and route YouTube URLs:
   ```python
   async def download_from_url(url: str) -> str:
       """Download a file from a URL to a temporary location.

       For YouTube URLs, uses yt-dlp to extract audio.
       For regular URLs, downloads the file directly.

       Args:
           url: The URL to download from (YouTube or direct audio file)

       Returns:
           Path to the downloaded/extracted temporary file

       Raises:
           HTTPException: 408 if download times out
           HTTPException: 400 if download fails or extension is invalid
           HTTPException: 503 if FFmpeg not available for YouTube
       """
       # Check if YouTube URL - route to youtube_handler
       if is_youtube_url(url):
           try:
               audio_path = download_youtube_audio(url)
               return str(audio_path)
           except FFmpegNotFoundError as e:
               raise HTTPException(
                   status_code=503,
                   detail=f"YouTube transcription unavailable: {str(e)}",
               )
           except YouTubeDownloadError as e:
               raise HTTPException(
                   status_code=400,
                   detail=f"YouTube download failed: {str(e)}",
               )

       # Original logic for regular URLs below...
       # (keep all existing code for non-YouTube URLs)
   ```

   Note: download_youtube_audio is sync but FastAPI handles this fine in an async context.
   For better async support, could wrap in run_in_executor but not required for v2.1.
  </action>
  <verify>
Verify code structure:
- DOWNLOADING status exists in JobStatus
- download_progress field exists in Job model with ge=0, le=100 validation
- file_handler imports from youtube_handler
- download_from_url checks is_youtube_url first
  </verify>
  <done>
DOWNLOADING status and download_progress field added; file_handler routes YouTube URLs to youtube_handler
  </done>
</task>

<task type="auto">
  <name>Task 2: Update health endpoint with YouTube capability</name>
  <files>cesar/api/server.py</files>
  <action>
Modify the /health endpoint to report FFmpeg and YouTube support status:

1. Add import at top of server.py:
   ```python
   from cesar.youtube_handler import check_ffmpeg_available
   ```

2. Update the health endpoint:
   ```python
   @app.get("/health")
   async def health():
       """Health check endpoint.

       Returns server health status, worker state, and YouTube capability.

       Returns:
           dict: Health status with:
               - status: "healthy" when server is operational
               - worker: "running" if worker task is active, "stopped" if done
               - youtube: object with ffmpeg_available and message
       """
       worker_task = getattr(app.state, "worker_task", None)

       if worker_task is None:
           worker_status = "stopped"
       elif worker_task.done():
           worker_status = "stopped"
       else:
           worker_status = "running"

       # Check YouTube capability (FFmpeg availability)
       ffmpeg_available, ffmpeg_message = check_ffmpeg_available()

       return {
           "status": "healthy",
           "worker": worker_status,
           "youtube": {
               "available": ffmpeg_available,
               "message": ffmpeg_message if not ffmpeg_available else "YouTube transcription supported",
           },
       }
   ```
  </action>
  <verify>
Verify code:
- health() endpoint returns youtube object with available and message fields
- check_ffmpeg_available imported from youtube_handler
  </verify>
  <done>
Health endpoint reports FFmpeg availability and YouTube support status
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for API YouTube support and download_progress</name>
  <files>tests/test_file_handler.py, tests/test_server.py, tests/test_models.py</files>
  <action>
1. In `tests/test_file_handler.py`, add YouTube URL handling tests:

   ```python
   import pytest
   from unittest.mock import patch, MagicMock
   from pathlib import Path
   import tempfile

   # Add to existing test file

   class TestYouTubeDownload:
       """Tests for YouTube URL handling in download_from_url."""

       @pytest.mark.asyncio
       @patch('cesar.api.file_handler.download_youtube_audio')
       @patch('cesar.api.file_handler.is_youtube_url')
       async def test_youtube_url_routed_to_handler(self, mock_is_youtube, mock_download):
           """Test that YouTube URLs are routed to youtube_handler."""
           mock_is_youtube.return_value = True
           mock_download.return_value = Path('/tmp/audio.m4a')

           from cesar.api.file_handler import download_from_url
           result = await download_from_url('https://www.youtube.com/watch?v=test123')

           mock_is_youtube.assert_called_once_with('https://www.youtube.com/watch?v=test123')
           mock_download.assert_called_once()
           assert result == '/tmp/audio.m4a'

       @pytest.mark.asyncio
       @patch('cesar.api.file_handler.download_youtube_audio')
       @patch('cesar.api.file_handler.is_youtube_url')
       async def test_youtube_ffmpeg_missing_returns_503(self, mock_is_youtube, mock_download):
           """Test that missing FFmpeg returns 503."""
           from cesar.youtube_handler import FFmpegNotFoundError
           from fastapi import HTTPException

           mock_is_youtube.return_value = True
           mock_download.side_effect = FFmpegNotFoundError("FFmpeg not found")

           from cesar.api.file_handler import download_from_url
           with pytest.raises(HTTPException) as exc_info:
               await download_from_url('https://www.youtube.com/watch?v=test123')

           assert exc_info.value.status_code == 503
           assert 'FFmpeg' in str(exc_info.value.detail)

       @pytest.mark.asyncio
       @patch('cesar.api.file_handler.download_youtube_audio')
       @patch('cesar.api.file_handler.is_youtube_url')
       async def test_youtube_download_error_returns_400(self, mock_is_youtube, mock_download):
           """Test that download errors return 400."""
           from cesar.youtube_handler import YouTubeUnavailableError
           from fastapi import HTTPException

           mock_is_youtube.return_value = True
           mock_download.side_effect = YouTubeUnavailableError("Video unavailable")

           from cesar.api.file_handler import download_from_url
           with pytest.raises(HTTPException) as exc_info:
               await download_from_url('https://www.youtube.com/watch?v=test123')

           assert exc_info.value.status_code == 400

       @pytest.mark.asyncio
       @patch('cesar.api.file_handler.is_youtube_url')
       async def test_non_youtube_url_uses_regular_download(self, mock_is_youtube):
           """Test that non-YouTube URLs use regular HTTP download."""
           mock_is_youtube.return_value = False

           # This will fail because the URL doesn't exist, but proves routing works
           from cesar.api.file_handler import download_from_url
           from fastapi import HTTPException

           with pytest.raises(HTTPException):
               await download_from_url('https://example.com/audio.mp3')

           mock_is_youtube.assert_called_once()
   ```

2. In `tests/test_models.py`, add download_progress validation tests:

   ```python
   # Add to existing test file or create new class

   class TestDownloadProgress:
       """Tests for download_progress field validation."""

       def test_download_progress_none_for_regular_jobs(self):
           """Test download_progress defaults to None."""
           job = Job(audio_path="/tmp/test.mp3")
           assert job.download_progress is None

       def test_download_progress_accepts_valid_values(self):
           """Test download_progress accepts 0-100."""
           job = Job(audio_path="/tmp/test.mp3", download_progress=0)
           assert job.download_progress == 0

           job = Job(audio_path="/tmp/test.mp3", download_progress=50)
           assert job.download_progress == 50

           job = Job(audio_path="/tmp/test.mp3", download_progress=100)
           assert job.download_progress == 100

       def test_download_progress_rejects_negative(self):
           """Test download_progress rejects negative values."""
           import pytest
           from pydantic import ValidationError

           with pytest.raises(ValidationError):
               Job(audio_path="/tmp/test.mp3", download_progress=-1)

       def test_download_progress_rejects_over_100(self):
           """Test download_progress rejects values over 100."""
           import pytest
           from pydantic import ValidationError

           with pytest.raises(ValidationError):
               Job(audio_path="/tmp/test.mp3", download_progress=101)
   ```

3. In `tests/test_server.py`, add health endpoint tests:

   ```python
   @pytest.mark.asyncio
   @patch('cesar.api.server.check_ffmpeg_available')
   async def test_health_reports_youtube_available(self, mock_ffmpeg):
       """Test health endpoint reports YouTube available when FFmpeg present."""
       mock_ffmpeg.return_value = (True, "")

       async with AsyncClient(app=app, base_url="http://test") as client:
           response = await client.get("/health")

       assert response.status_code == 200
       data = response.json()
       assert data["youtube"]["available"] is True
       assert "supported" in data["youtube"]["message"].lower()

   @pytest.mark.asyncio
   @patch('cesar.api.server.check_ffmpeg_available')
   async def test_health_reports_youtube_unavailable(self, mock_ffmpeg):
       """Test health endpoint reports YouTube unavailable when FFmpeg missing."""
       mock_ffmpeg.return_value = (False, "FFmpeg not found")

       async with AsyncClient(app=app, base_url="http://test") as client:
           response = await client.get("/health")

       assert response.status_code == 200
       data = response.json()
       assert data["youtube"]["available"] is False
       assert "FFmpeg" in data["youtube"]["message"]
   ```
  </action>
  <verify>
Run: `python -m pytest tests/test_file_handler.py tests/test_server.py tests/test_models.py -v -k "youtube or download_progress"`
All YouTube-related API tests and download_progress validation tests pass
  </verify>
  <done>
Unit tests cover YouTube URL routing, error handling, health endpoint YouTube status, and download_progress validation
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `python -m pytest tests/test_models.py -v` - download_progress validation tests pass
2. Run `python -m pytest tests/test_file_handler.py -v` - all tests pass
3. Run `python -m pytest tests/test_server.py -v` - all tests pass
4. Run `python -m pytest tests/` - all project tests pass
</verification>

<success_criteria>
- JobStatus enum includes DOWNLOADING value
- Job model includes download_progress field (Optional[int], 0-100, validated)
- file_handler.download_from_url() routes YouTube URLs to youtube_handler
- Health endpoint returns youtube.available and youtube.message
- FFmpeg-not-found returns 503, download errors return 400
- All unit tests pass including new YouTube tests and download_progress validation
</success_criteria>

<output>
After completion, create `.planning/phases/07-interface-integration/07-02-SUMMARY.md`
</output>
