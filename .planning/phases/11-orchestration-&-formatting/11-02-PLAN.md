---
phase: 11-orchestration-formatting
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - cesar/orchestrator.py
  - cesar/transcriber.py
  - tests/test_orchestrator.py
autonomous: true

must_haves:
  truths:
    - "Orchestrator coordinates transcription then diarization then formatting sequentially"
    - "Fallback to plain .txt transcript when diarization fails"
    - "Progress updates flow from transcription through diarization to formatting"
    - "Debug mode saves intermediate files for troubleshooting"
    - "Result object reports success/failure status and metrics"
  artifacts:
    - path: "cesar/orchestrator.py"
      provides: "TranscriptionOrchestrator class"
      exports: ["TranscriptionOrchestrator", "OrchestrationResult"]
    - path: "tests/test_orchestrator.py"
      provides: "Unit tests for orchestrator"
      min_lines: 150
  key_links:
    - from: "cesar/orchestrator.py"
      to: "cesar/transcriber.py"
      via: "calls transcribe_to_segments()"
      pattern: "transcriber\\.transcribe_to_segments"
    - from: "cesar/orchestrator.py"
      to: "cesar/diarization.py"
      via: "calls diarize()"
      pattern: "diarizer\\.diarize"
    - from: "cesar/orchestrator.py"
      to: "cesar/transcript_formatter.py"
      via: "calls format_with_speakers()"
      pattern: "formatter\\.format_with_speakers"
    - from: "cesar/orchestrator.py"
      to: "cesar/timestamp_aligner.py"
      via: "calls align_timestamps()"
      pattern: "align_timestamps"
---

<objective>
Create orchestrator to coordinate transcription, diarization, and formatting pipeline.

Purpose: Single entry point that coordinates all components, handles errors gracefully with fallback, reports unified progress, and produces final output files.

Output:
- cesar/orchestrator.py with TranscriptionOrchestrator class
- cesar/transcriber.py extended with transcribe_to_segments() method
- tests/test_orchestrator.py with comprehensive test coverage
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-orchestration-&-formatting/11-CONTEXT.md
@.planning/phases/11-orchestration-&-formatting/11-RESEARCH.md
@.planning/phases/11-orchestration-&-formatting/11-01-SUMMARY.md
@cesar/transcriber.py
@cesar/diarization.py
@cesar/timestamp_aligner.py
@cesar/transcript_formatter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend transcriber with transcribe_to_segments method</name>
  <files>cesar/transcriber.py</files>
  <action>
Add a new method to AudioTranscriber that returns TranscriptionSegment list instead of writing to file.

The current transcribe_file() method writes text to a file and returns a dict with metadata. The orchestrator needs the actual segment data (start, end, text) to pass to align_timestamps().

Add method to AudioTranscriber class:

```python
def transcribe_to_segments(
    self,
    input_path: str,
    progress_callback: Optional[Callable[[float, int, float], None]] = None,
    max_duration_minutes: Optional[int] = None,
    start_time_seconds: Optional[float] = None,
    end_time_seconds: Optional[float] = None
) -> tuple[list["TranscriptionSegment"], dict[str, Any]]:
    """
    Transcribe audio file and return segments with timestamps.

    Similar to transcribe_file() but returns segment data instead of writing to file.
    This enables the orchestrator to pass segments to the timestamp aligner.

    Args:
        input_path: Path to input audio file
        progress_callback: Optional callback for progress updates
        max_duration_minutes: Optional limit to first N minutes
        start_time_seconds: Optional start time
        end_time_seconds: Optional end time

    Returns:
        Tuple of (segments, metadata) where:
        - segments: List of TranscriptionSegment(start, end, text)
        - metadata: Dict with language, language_probability, audio_duration,
                   processing_time, speed_ratio, segment_count
    """
```

Implementation:
1. Import TranscriptionSegment at top of file:
   `from cesar.timestamp_aligner import TranscriptionSegment`

2. Copy transcribe_file() logic but instead of writing to file:
   - Collect segments into a list
   - Each segment becomes TranscriptionSegment(start=segment.start, end=segment.end, text=segment.text.strip())
   - Return (segments_list, metadata_dict)

3. Optionally refactor transcribe_file() to call transcribe_to_segments() internally then write results to file (reduces duplication).

Add test for new method in test_transcriber.py (mock the model).
  </action>
  <verify>python -c "from cesar.transcriber import AudioTranscriber; print('transcribe_to_segments' in dir(AudioTranscriber))" prints True</verify>
  <done>AudioTranscriber.transcribe_to_segments() method exists and returns (list[TranscriptionSegment], dict)</done>
</task>

<task type="auto">
  <name>Task 2: Create orchestrator module with result dataclass</name>
  <files>cesar/orchestrator.py</files>
  <action>
Create TranscriptionOrchestrator class that coordinates the full pipeline.

Implementation:

1. Create OrchestrationResult frozen dataclass:
   ```python
   @dataclass(frozen=True)
   class OrchestrationResult:
       output_path: Path
       speakers_detected: int
       audio_duration: float
       transcription_time: float
       diarization_time: Optional[float]
       formatting_time: float
       diarization_succeeded: bool

       @property
       def total_processing_time(self) -> float

       @property
       def speed_ratio(self) -> float
   ```

2. Create TranscriptionOrchestrator class:
   ```python
   class TranscriptionOrchestrator:
       def __init__(
           self,
           transcriber: AudioTranscriber,
           diarizer: Optional[SpeakerDiarizer] = None,
           formatter: Optional[MarkdownTranscriptFormatter] = None
       )

       def orchestrate(
           self,
           audio_path: Path,
           output_path: Path,
           enable_diarization: bool = True,
           keep_intermediate: bool = False,
           progress_callback: Optional[Callable[[str, float], None]] = None
       ) -> OrchestrationResult
   ```

3. Orchestrate method flow:
   a. Step 1 (0-60%): Transcribe audio
      - Call transcriber.transcribe_to_segments() (returns segments list + metadata)
      - Update progress: "Transcribing...", 0-60%
      - Store segments for alignment step

   b. Step 2 (60-90%): Diarize (if enabled)
      - Call diarizer.diarize()
      - Update progress: "Detecting speakers...", 60-90%
      - If diarization fails: log warning, set diarization_succeeded=False

   c. Step 3 (90-100%): Format and save
      - If diarization succeeded:
        - Call align_timestamps(segments, diarization_result) to merge
        - Call formatter.format_with_speakers()
        - Save as .md file
        - Update progress: "Formatting...", 90-100%
      - If diarization failed or disabled:
        - Join segment texts with newlines
        - Save plain transcript as .txt with note header
        - Log info: "Saved plain transcript (speaker detection unavailable)"

4. Progress callback signature: (step_name: str, overall_percentage: float)
   - Allows UI to show both current step and overall progress

5. keep_intermediate flag:
   - If True: save transcription to {output_stem}_transcription.txt
   - If True: save diarization to {output_stem}_diarization.json
   - Use logging.info to report intermediate file locations

6. Error handling:
   - Transcription errors: let them propagate (transcription is required)
   - Diarization errors: catch, log warning, fall back to plain transcript
   - Formatting errors: catch, log warning, fall back to plain transcript

7. File extension handling:
   - With diarization: always save as .md
   - Without diarization (disabled or failed): always save as .txt
   - Override user-provided extension if needed, log the change

Import dependencies:
- from cesar.transcriber import AudioTranscriber
- from cesar.diarization import SpeakerDiarizer, DiarizationError, DiarizationResult
- from cesar.timestamp_aligner import align_timestamps, TranscriptionSegment, AlignedSegment
- from cesar.transcript_formatter import MarkdownTranscriptFormatter, FormattingError
  </action>
  <verify>python -c "from cesar.orchestrator import TranscriptionOrchestrator, OrchestrationResult; print('Import OK')"</verify>
  <done>TranscriptionOrchestrator class exists with orchestrate() method and all helper methods</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive orchestrator tests</name>
  <files>tests/test_orchestrator.py</files>
  <action>
Create unit tests for orchestrator using mocked components.

Test cases:

1. test_orchestrate_success_with_diarization
   - Mock transcriber.transcribe_to_segments() to return segments + metadata
   - Mock diarizer, formatter
   - Verify correct flow: transcribe -> diarize -> align_timestamps -> format -> save
   - Verify .md output extension
   - Verify OrchestrationResult has correct values

2. test_orchestrate_diarization_disabled
   - Set enable_diarization=False
   - Verify diarizer.diarize() NOT called
   - Verify .txt output extension
   - Verify diarization_succeeded=False in result

3. test_orchestrate_diarization_fails_gracefully
   - Mock diarizer.diarize() to raise DiarizationError
   - Verify fallback to plain .txt transcript
   - Verify warning logged
   - Verify diarization_succeeded=False in result

4. test_orchestrate_transcription_fails_propagates
   - Mock transcriber to raise exception
   - Verify exception propagates (not caught)

5. test_orchestrate_progress_callback
   - Verify callback called with correct steps and percentages
   - Should see: ("Transcribing...", 0-60), ("Detecting speakers...", 60-90), ("Formatting...", 90-100)

6. test_orchestrate_keep_intermediate_files
   - Set keep_intermediate=True
   - Verify intermediate files created
   - Verify logging of file locations

7. test_orchestrate_file_extension_override
   - Pass output_path with .txt extension
   - With diarization success, verify saved as .md
   - Verify logging of extension change

8. test_orchestrate_single_speaker_no_labels
   - Mock diarizer to return single speaker
   - Verify formatter still called (output will show single speaker format)

9. test_orchestration_result_properties
   - Test total_processing_time calculation
   - Test speed_ratio calculation

10. test_orchestrate_formatting_error_fallback
    - Mock formatter to raise FormattingError
    - Verify fallback to plain .txt

Mock strategy:
- Use unittest.mock.patch to mock AudioTranscriber, SpeakerDiarizer, MarkdownTranscriptFormatter
- Use MagicMock for return values
- Use tmp_path fixture for output files

Run tests to verify coverage.
  </action>
  <verify>python -m pytest tests/test_orchestrator.py -v shows all tests passing</verify>
  <done>10+ test cases covering success paths, error handling, progress, and intermediate files</done>
</task>

<task type="auto">
  <name>Task 4: Integration verification and commit</name>
  <files>cesar/orchestrator.py, cesar/transcriber.py, tests/test_orchestrator.py</files>
  <action>
Verify full integration and commit.

1. Run full test suite:
   python -m pytest tests/ -v
   - All existing tests pass
   - All new orchestrator tests pass
   - All formatter tests pass (from Plan 01)

2. Verify imports work throughout chain:
   ```python
   from cesar.orchestrator import TranscriptionOrchestrator, OrchestrationResult
   from cesar.transcriber import AudioTranscriber
   from cesar.diarization import SpeakerDiarizer
   from cesar.transcript_formatter import MarkdownTranscriptFormatter
   from cesar.timestamp_aligner import TranscriptionSegment, align_timestamps

   # Verify types are compatible
   transcriber = AudioTranscriber()
   # Can't fully test without models, but imports work
   print("All imports OK")
   ```

3. Verify docstrings and type hints are complete:
   - TranscriptionOrchestrator.__init__ has docstring
   - orchestrate() has full docstring with Args/Returns/Raises
   - OrchestrationResult has docstring explaining each field
   - transcribe_to_segments() has full docstring

4. Commit with descriptive message.
  </action>
  <verify>python -m pytest tests/ -v shows all tests passing (full suite)</verify>
  <done>Full test suite passes, orchestrator committed, Phase 11 complete</done>
</task>

</tasks>

<verification>
1. Import works: `from cesar.orchestrator import TranscriptionOrchestrator, OrchestrationResult`
2. Transcriber extended: `transcribe_to_segments()` method exists
3. Orchestrator tests pass: `python -m pytest tests/test_orchestrator.py -v`
4. Full test suite passes: `python -m pytest tests/ -v`
5. Orchestrator correctly coordinates transcriber -> diarizer -> align_timestamps -> formatter flow
6. Fallback to plain text works when diarization fails
</verification>

<success_criteria>
- TranscriptionOrchestrator class exists with orchestrate() method
- AudioTranscriber.transcribe_to_segments() method returns (list[TranscriptionSegment], dict)
- OrchestrationResult frozen dataclass with all required fields
- Diarization failure gracefully falls back to plain .txt transcript
- Progress callback receives step names and percentages
- keep_intermediate flag creates debug files when True
- File extensions handled correctly (.md for diarized, .txt for plain)
- All 10+ test cases pass
- Full test suite remains green
</success_criteria>

<output>
After completion, create `.planning/phases/11-orchestration-&-formatting/11-02-SUMMARY.md`
</output>
