---
phase: 10-speaker-diarization-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cesar/diarization.py
  - cesar/config.py
  - pyproject.toml
  - tests/test_diarization.py
autonomous: true

must_haves:
  truths:
    - "Diarization pipeline initializes with HuggingFace token"
    - "Pipeline auto-downloads models to ~/.cache/huggingface/ on first use"
    - "User sees progress spinner during diarization"
    - "GPU is used when available for 10-20x speedup"
    - "Min/max speaker parameters are passed to pipeline"
  artifacts:
    - path: "cesar/diarization.py"
      provides: "SpeakerDiarizer class with pyannote pipeline"
      exports: ["SpeakerDiarizer", "DiarizationResult", "DiarizationError", "AuthenticationError"]
    - path: "cesar/config.py"
      provides: "Extended config with hf_token field"
      contains: "hf_token"
    - path: "pyproject.toml"
      provides: "pyannote.audio dependency"
      contains: "pyannote.audio"
    - path: "tests/test_diarization.py"
      provides: "Unit tests for diarization module"
      min_lines: 50
  key_links:
    - from: "cesar/diarization.py"
      to: "pyannote.audio.Pipeline"
      via: "Pipeline.from_pretrained()"
      pattern: "Pipeline\\.from_pretrained"
    - from: "cesar/diarization.py"
      to: "cesar/config.py"
      via: "hf_token from config"
      pattern: "hf_token"
---

<objective>
Create the core speaker diarization module using pyannote.audio pipeline with HuggingFace authentication, GPU optimization, and progress feedback.

Purpose: Enable speaker detection in audio files as foundation for speaker-labeled transcripts
Output: SpeakerDiarizer class that identifies speakers and returns timestamped speaker segments
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-speaker-diarization-core/10-RESEARCH.md
@.planning/phases/10-speaker-diarization-core/10-CONTEXT.md
@cesar/config.py
@cesar/transcriber.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pyannote.audio dependency and extend config for HF token</name>
  <files>
    pyproject.toml
    cesar/config.py
  </files>
  <action>
    1. Add pyannote.audio to pyproject.toml dependencies:
       - Add "pyannote.audio>=3.1.0" to dependencies list
       - torch is a transitive dependency, no need to add explicitly

    2. Extend CesarConfig in cesar/config.py:
       - Add `hf_token: Optional[str] = None` field
       - Add docstring: "HuggingFace token for pyannote model download"
       - No validation needed (any string is valid, empty means use env/cached)

    3. Update DEFAULT_CONFIG_TEMPLATE with hf_token documentation:
       ```
       # HuggingFace token for speaker diarization model download
       # Required on first use to download pyannote models
       # Get your token at: https://hf.co/settings/tokens
       # Accept model conditions at: https://hf.co/pyannote/speaker-diarization-3.1
       # Default: use cached token from ~/.cache/huggingface/token
       # Example: hf_token = "hf_xxxxx"
       ```
  </action>
  <verify>
    Run: `python -c "from cesar.config import CesarConfig; c = CesarConfig(hf_token='test'); print(c.hf_token)"`
    Expected: prints "test"
  </verify>
  <done>
    - pyproject.toml includes pyannote.audio>=3.1.0
    - CesarConfig has hf_token field
    - Config template documents hf_token
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SpeakerDiarizer class with pyannote pipeline</name>
  <files>
    cesar/diarization.py
  </files>
  <action>
    Create cesar/diarization.py with:

    1. Exception classes:
       ```python
       class DiarizationError(Exception):
           """Base exception for diarization errors."""
           pass

       class AuthenticationError(DiarizationError):
           """HuggingFace authentication failed."""
           pass
       ```

    2. DiarizationResult dataclass or Pydantic model:
       ```python
       @dataclass
       class SpeakerSegment:
           start: float      # Start time in seconds
           end: float        # End time in seconds
           speaker: str      # Speaker label (SPEAKER_00, SPEAKER_01, etc.)

       @dataclass
       class DiarizationResult:
           segments: list[SpeakerSegment]
           speaker_count: int
           audio_duration: float
       ```

    3. SpeakerDiarizer class:
       ```python
       class SpeakerDiarizer:
           DEFAULT_MODEL = "pyannote/speaker-diarization-3.1"
           DEFAULT_MIN_SPEAKERS = 1
           DEFAULT_MAX_SPEAKERS = 5

           def __init__(self, hf_token: Optional[str] = None, model_name: Optional[str] = None):
               """Initialize diarization pipeline.

               Args:
                   hf_token: HuggingFace token. If None, tries:
                            1. HF_TOKEN environment variable
                            2. Cached token from ~/.cache/huggingface/token
                   model_name: Pyannote model name. Defaults to speaker-diarization-3.1
               """
               self.model_name = model_name or self.DEFAULT_MODEL
               self.hf_token = self._resolve_token(hf_token)
               self.pipeline = None

           def _resolve_token(self, provided_token: Optional[str]) -> Optional[str]:
               """Resolve HF token from config, env, or cache."""
               if provided_token:
                   return provided_token

               # Try environment variable
               env_token = os.getenv('HF_TOKEN')
               if env_token:
                   return env_token

               # Try cached token
               token_path = Path.home() / '.cache' / 'huggingface' / 'token'
               if token_path.exists():
                   return token_path.read_text().strip()

               return None

           def _load_pipeline(self) -> None:
               """Load pyannote pipeline with GPU optimization."""
               if self.pipeline is not None:
                   return

               try:
                   from pyannote.audio import Pipeline
               except ImportError:
                   raise DiarizationError(
                       "pyannote.audio not installed. Run: pip install pyannote.audio"
                   )

               try:
                   self.pipeline = Pipeline.from_pretrained(
                       self.model_name,
                       use_auth_token=self.hf_token
                   )
               except Exception as e:
                   error_str = str(e)
                   if "401" in error_str or "Unauthorized" in error_str or "access" in error_str.lower():
                       raise AuthenticationError(
                           "HuggingFace authentication failed.\n"
                           "1. Get token at: https://hf.co/settings/tokens\n"
                           "2. Accept conditions at: https://hf.co/pyannote/speaker-diarization-3.1\n"
                           "3. Accept conditions at: https://hf.co/pyannote/segmentation-3.0\n"
                           "4. Set hf_token in config or HF_TOKEN environment variable"
                       ) from e
                   raise DiarizationError(f"Failed to load diarization model: {e}") from e

               # Move to GPU if available
               import torch
               if torch.cuda.is_available():
                   self.pipeline.to(torch.device("cuda"))

           def diarize(
               self,
               audio_path: str,
               min_speakers: Optional[int] = None,
               max_speakers: Optional[int] = None,
               progress_callback: Optional[Callable[[str], None]] = None
           ) -> DiarizationResult:
               """Run speaker diarization on audio file.

               Args:
                   audio_path: Path to audio file
                   min_speakers: Minimum expected speakers (default: 1)
                   max_speakers: Maximum expected speakers (default: 5)
                   progress_callback: Optional callback for progress updates

               Returns:
                   DiarizationResult with speaker segments
               """
               self._load_pipeline()

               # Apply defaults
               min_spk = min_speakers if min_speakers is not None else self.DEFAULT_MIN_SPEAKERS
               max_spk = max_speakers if max_speakers is not None else self.DEFAULT_MAX_SPEAKERS

               # Build kwargs for pipeline
               kwargs = {
                   'min_speakers': min_spk,
                   'max_speakers': max_spk,
               }

               # Run diarization with optional progress hook
               if progress_callback:
                   from pyannote.audio.pipelines.utils.hook import ProgressHook
                   with ProgressHook() as hook:
                       progress_callback("Detecting speakers...")
                       diarization = self.pipeline(audio_path, hook=hook, **kwargs)
               else:
                   diarization = self.pipeline(audio_path, **kwargs)

               # Convert to DiarizationResult
               segments = []
               speakers_seen = set()
               for turn, _, speaker in diarization.itertracks(yield_label=True):
                   segments.append(SpeakerSegment(
                       start=turn.start,
                       end=turn.end,
                       speaker=speaker
                   ))
                   speakers_seen.add(speaker)

               # Get audio duration from last segment end (approximate)
               audio_duration = segments[-1].end if segments else 0.0

               return DiarizationResult(
                   segments=segments,
                   speaker_count=len(speakers_seen),
                   audio_duration=audio_duration
               )
       ```

    Key implementation notes:
    - Use dataclasses (not Pydantic) for SpeakerSegment/DiarizationResult - simple data containers
    - Pipeline loaded lazily on first diarize() call
    - GPU detected via torch.cuda.is_available() and pipeline moved if available
    - Progress hook from pyannote integrated but wrapped simply (just calls callback with status string)
    - Default speaker range 1-5 as per CONTEXT.md decisions
  </action>
  <verify>
    Run: `python -c "from cesar.diarization import SpeakerDiarizer, DiarizationResult, SpeakerSegment; print('imports ok')"`
    Expected: prints "imports ok"
  </verify>
  <done>
    - cesar/diarization.py exists with SpeakerDiarizer class
    - Exports: SpeakerDiarizer, DiarizationResult, SpeakerSegment, DiarizationError, AuthenticationError
    - Pipeline loads from pyannote with HF token
    - GPU used when available
    - Min/max speakers passed to pipeline
    - Progress callback supported
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for diarization module</name>
  <files>
    tests/test_diarization.py
  </files>
  <action>
    Create tests/test_diarization.py with unit tests that mock pyannote:

    ```python
    """Unit tests for diarization module."""
    import unittest
    from unittest.mock import Mock, patch, MagicMock
    from pathlib import Path
    import os

    from cesar.diarization import (
        SpeakerDiarizer,
        SpeakerSegment,
        DiarizationResult,
        DiarizationError,
        AuthenticationError,
    )


    class TestSpeakerDiarizer(unittest.TestCase):
        """Tests for SpeakerDiarizer class."""

        def test_init_with_token(self):
            """Test initialization with provided token."""
            diarizer = SpeakerDiarizer(hf_token="test_token")
            self.assertEqual(diarizer.hf_token, "test_token")

        def test_init_default_model(self):
            """Test default model name."""
            diarizer = SpeakerDiarizer()
            self.assertEqual(diarizer.model_name, "pyannote/speaker-diarization-3.1")

        @patch.dict(os.environ, {"HF_TOKEN": "env_token"})
        def test_token_from_environment(self):
            """Test token resolution from environment variable."""
            diarizer = SpeakerDiarizer()
            self.assertEqual(diarizer.hf_token, "env_token")

        def test_token_from_cache(self):
            """Test token resolution from cached file."""
            with patch.object(Path, 'exists', return_value=True):
                with patch.object(Path, 'read_text', return_value="cached_token\n"):
                    diarizer = SpeakerDiarizer()
                    self.assertEqual(diarizer.hf_token, "cached_token")

        @patch("cesar.diarization.Pipeline")
        def test_load_pipeline_success(self, mock_pipeline_class):
            """Test successful pipeline loading."""
            mock_pipeline = Mock()
            mock_pipeline_class.from_pretrained.return_value = mock_pipeline

            with patch("torch.cuda.is_available", return_value=False):
                diarizer = SpeakerDiarizer(hf_token="token")
                diarizer._load_pipeline()

            mock_pipeline_class.from_pretrained.assert_called_once_with(
                "pyannote/speaker-diarization-3.1",
                use_auth_token="token"
            )

        @patch("cesar.diarization.Pipeline")
        def test_load_pipeline_auth_error(self, mock_pipeline_class):
            """Test authentication error handling."""
            mock_pipeline_class.from_pretrained.side_effect = Exception("401 Unauthorized")

            diarizer = SpeakerDiarizer(hf_token="bad_token")
            with self.assertRaises(AuthenticationError) as ctx:
                diarizer._load_pipeline()

            self.assertIn("HuggingFace authentication failed", str(ctx.exception))

        @patch("cesar.diarization.Pipeline")
        @patch("torch.cuda.is_available", return_value=True)
        def test_gpu_detection(self, mock_cuda, mock_pipeline_class):
            """Test GPU detection and pipeline movement."""
            mock_pipeline = Mock()
            mock_pipeline_class.from_pretrained.return_value = mock_pipeline

            diarizer = SpeakerDiarizer(hf_token="token")
            diarizer._load_pipeline()

            mock_pipeline.to.assert_called_once()

        @patch("cesar.diarization.Pipeline")
        @patch("torch.cuda.is_available", return_value=False)
        def test_diarize_with_defaults(self, mock_cuda, mock_pipeline_class):
            """Test diarization with default speaker range."""
            # Set up mock pipeline
            mock_pipeline = Mock()
            mock_pipeline_class.from_pretrained.return_value = mock_pipeline

            # Mock diarization result
            mock_turn = Mock()
            mock_turn.start = 0.0
            mock_turn.end = 5.0
            mock_pipeline.return_value.itertracks.return_value = [
                (mock_turn, None, "SPEAKER_00")
            ]

            diarizer = SpeakerDiarizer(hf_token="token")
            diarizer.pipeline = mock_pipeline  # Skip loading

            # Call diarize
            result = diarizer.diarize("test.wav")

            # Check pipeline called with default min/max
            mock_pipeline.assert_called_with(
                "test.wav",
                min_speakers=1,
                max_speakers=5,
            )

        @patch("cesar.diarization.Pipeline")
        @patch("torch.cuda.is_available", return_value=False)
        def test_diarize_with_custom_speakers(self, mock_cuda, mock_pipeline_class):
            """Test diarization with custom speaker range."""
            mock_pipeline = Mock()
            mock_pipeline_class.from_pretrained.return_value = mock_pipeline

            mock_turn = Mock()
            mock_turn.start = 0.0
            mock_turn.end = 5.0
            mock_pipeline.return_value.itertracks.return_value = [
                (mock_turn, None, "SPEAKER_00")
            ]

            diarizer = SpeakerDiarizer(hf_token="token")
            diarizer.pipeline = mock_pipeline

            result = diarizer.diarize("test.wav", min_speakers=2, max_speakers=4)

            mock_pipeline.assert_called_with(
                "test.wav",
                min_speakers=2,
                max_speakers=4,
            )


    class TestDiarizationResult(unittest.TestCase):
        """Tests for DiarizationResult dataclass."""

        def test_result_creation(self):
            """Test creating a DiarizationResult."""
            segments = [
                SpeakerSegment(start=0.0, end=5.0, speaker="SPEAKER_00"),
                SpeakerSegment(start=5.0, end=10.0, speaker="SPEAKER_01"),
            ]
            result = DiarizationResult(
                segments=segments,
                speaker_count=2,
                audio_duration=10.0
            )

            self.assertEqual(len(result.segments), 2)
            self.assertEqual(result.speaker_count, 2)
            self.assertEqual(result.audio_duration, 10.0)

        def test_segment_creation(self):
            """Test creating a SpeakerSegment."""
            segment = SpeakerSegment(start=1.5, end=3.7, speaker="SPEAKER_00")

            self.assertEqual(segment.start, 1.5)
            self.assertEqual(segment.end, 3.7)
            self.assertEqual(segment.speaker, "SPEAKER_00")


    if __name__ == "__main__":
        unittest.main()
    ```

    Key test coverage:
    - Token resolution (provided, env, cached)
    - Pipeline loading (success, auth error)
    - GPU detection
    - Diarize with default and custom speaker ranges
    - Result dataclasses
  </action>
  <verify>
    Run: `python -m pytest tests/test_diarization.py -v`
    Expected: All tests pass
  </verify>
  <done>
    - tests/test_diarization.py exists with unit tests
    - Tests cover token resolution, pipeline loading, auth errors, GPU detection
    - Tests mock pyannote to avoid model download during testing
    - All tests pass
  </done>
</task>

</tasks>

<verification>
1. Import test: `python -c "from cesar.diarization import SpeakerDiarizer; print('ok')"`
2. Config test: `python -c "from cesar.config import CesarConfig; c = CesarConfig(hf_token='x'); print(c.hf_token)"`
3. Unit tests: `python -m pytest tests/test_diarization.py -v`
4. Verify pyproject.toml has pyannote.audio in dependencies
</verification>

<success_criteria>
- cesar/diarization.py exists with SpeakerDiarizer class
- SpeakerDiarizer initializes pyannote pipeline with HF token
- Pipeline uses GPU when available (torch.cuda.is_available())
- Diarize method accepts min_speakers, max_speakers parameters
- Progress callback supported for UI integration
- Config extended with hf_token field
- pyproject.toml includes pyannote.audio>=3.1.0
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-speaker-diarization-core/10-01-SUMMARY.md`
</output>
