---
phase: 09-configuration-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cesar/config.py
  - tests/test_config.py
autonomous: true

must_haves:
  truths:
    - "Config loading succeeds with valid TOML file"
    - "Config loading returns defaults when file missing"
    - "Invalid config values produce clear error messages"
    - "Cross-field validation catches min_speakers > max_speakers"
    - "Default config template includes inline documentation"
  artifacts:
    - path: "cesar/config.py"
      provides: "CesarConfig model, load_config function, config template"
      exports: ["CesarConfig", "load_config", "get_cli_config_path", "get_api_config_path", "create_default_config", "ConfigError"]
    - path: "tests/test_config.py"
      provides: "Unit tests for config module"
      min_lines: 100
  key_links:
    - from: "cesar/config.py"
      to: "pydantic.BaseModel"
      via: "CesarConfig inherits BaseModel"
      pattern: "class CesarConfig\\(BaseModel\\)"
    - from: "cesar/config.py"
      to: "tomllib"
      via: "TOML parsing"
      pattern: "tomllib\\.load"
---

<objective>
Create the configuration system foundation: Pydantic model for config validation, TOML loading functions, path helpers for CLI and API, and a default config template with inline documentation.

Purpose: Enable consistent configuration across CLI and API with validated settings and clear error messages on misconfiguration.
Output: cesar/config.py module with CesarConfig model, loading functions, and comprehensive tests.
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-configuration-system/09-CONTEXT.md
@.planning/phases/09-configuration-system/09-RESEARCH.md
@cesar/api/models.py  # Pydantic patterns in use
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config module with Pydantic model and TOML loading</name>
  <files>cesar/config.py</files>
  <action>
Create cesar/config.py with:

1. **ConfigError exception class** for config-specific errors

2. **CesarConfig Pydantic model** with:
   - `diarize: bool = False` - enable speaker identification by default
   - `min_speakers: int | None = None` - minimum speakers to detect
   - `max_speakers: int | None = None` - maximum speakers to detect
   - `model_config = ConfigDict(extra='forbid')` to reject unknown keys
   - Field validator for min_speakers and max_speakers (must be >= 1 if set)
   - Model validator (mode='after') to ensure min_speakers <= max_speakers when both set
   - Clear ValueError messages with examples (per CONTEXT.md decision)

3. **Path helper functions**:
   - `get_cli_config_path() -> Path` returns `~/.config/cesar/config.toml` (expanded)
   - `get_api_config_path() -> Path` returns `Path.cwd() / "config.toml"`

4. **load_config(config_path: Path) -> CesarConfig** function:
   - Return CesarConfig() defaults if file doesn't exist
   - Open file in binary mode ('rb') for tomllib
   - Catch tomllib.TOMLDecodeError, raise ConfigError with line/column info
   - Catch pydantic ValidationError, format user-friendly message listing each field error
   - Return validated CesarConfig instance

5. **DEFAULT_CONFIG_TEMPLATE** constant (f-string template):
   - Include header comment explaining file location and CLI override behavior
   - Show `diarize = false` with comment explaining what it does
   - Show `# min_speakers = 2` commented out with explanation
   - Show `# max_speakers = 4` commented out with explanation
   - Use clear, helpful comments that make the config self-documenting

6. **create_default_config(config_path: Path) -> None** function:
   - Create parent directories with mkdir(parents=True, exist_ok=True)
   - Write DEFAULT_CONFIG_TEMPLATE to file

Follow existing Pydantic patterns from cesar/api/models.py (ConfigDict, field_validator, etc.)
  </action>
  <verify>
    - `python -c "from cesar.config import CesarConfig, load_config; print('Import OK')"` succeeds
    - `python -c "from cesar.config import CesarConfig; c = CesarConfig(); print(c.diarize, c.min_speakers)"` prints `False None`
  </verify>
  <done>
    - CesarConfig model validates diarize, min_speakers, max_speakers with correct types and ranges
    - load_config returns defaults when file missing, raises ConfigError on invalid TOML
    - Path helpers return correct platform-appropriate paths
    - Template includes inline documentation for all settings
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive unit tests for config module</name>
  <files>tests/test_config.py</files>
  <action>
Create tests/test_config.py with unittest tests covering:

1. **CesarConfig model tests**:
   - test_default_values: diarize=False, min/max_speakers=None
   - test_valid_diarize_true: accepts diarize=True
   - test_valid_min_speakers: accepts integer >= 1
   - test_valid_max_speakers: accepts integer >= 1
   - test_invalid_min_speakers_zero: rejects 0
   - test_invalid_min_speakers_negative: rejects -1
   - test_invalid_max_speakers_zero: rejects 0
   - test_invalid_min_speakers_string: rejects "auto" with clear message
   - test_min_greater_than_max: rejects min_speakers > max_speakers
   - test_extra_field_rejected: rejects unknown field like "diarzie"

2. **load_config tests**:
   - test_load_missing_file: returns defaults
   - test_load_valid_config: parses valid TOML
   - test_load_invalid_toml_syntax: raises ConfigError with line info
   - test_load_invalid_value: raises ConfigError with field name and message
   - test_load_unknown_key: raises ConfigError (extra='forbid')

3. **Path helper tests**:
   - test_cli_config_path: returns ~/.config/cesar/config.toml (expanded)
   - test_api_config_path: returns cwd/config.toml

4. **create_default_config tests**:
   - test_creates_file: file exists after call
   - test_creates_directories: parent dirs created
   - test_file_contents: contains expected settings

Use tempfile.TemporaryDirectory for file system tests.
Follow existing test patterns (unittest.TestCase, descriptive test names).
  </action>
  <verify>
    - `python -m pytest tests/test_config.py -v` passes all tests
    - `python -m pytest tests/test_config.py --tb=short` shows no failures
  </verify>
  <done>
    - All config module functionality has test coverage
    - Tests verify both happy paths and error cases
    - Tests pass and provide clear failure messages
  </done>
</task>

</tasks>

<verification>
- All imports work: `python -c "from cesar.config import *"`
- All tests pass: `python -m pytest tests/test_config.py -v`
- Config model rejects invalid values with clear messages
- Default template is readable and self-documenting
</verification>

<success_criteria>
- cesar/config.py exists with CesarConfig, load_config, path helpers, template
- tests/test_config.py exists with comprehensive coverage
- All tests pass
- Invalid configs produce clear, actionable error messages
</success_criteria>

<output>
After completion, create `.planning/phases/09-configuration-system/09-01-SUMMARY.md`
</output>
