---
phase: 09-configuration-system
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - cesar/cli.py
  - cesar/api/server.py
  - tests/test_cli.py
  - tests/test_server.py
autonomous: true

must_haves:
  truths:
    - "CLI loads config from ~/.config/cesar/config.toml on startup"
    - "API loads config from local config.toml on startup"
    - "CLI arguments override config file values"
    - "Invalid config produces clear error at startup (fail fast)"
    - "Missing config file uses defaults silently (no error)"
  artifacts:
    - path: "cesar/cli.py"
      provides: "Config loading and CLI override merging"
      contains: "load_config"
    - path: "cesar/api/server.py"
      provides: "Config loading at API startup"
      contains: "load_config"
  key_links:
    - from: "cesar/cli.py"
      to: "cesar/config.py"
      via: "imports load_config and get_cli_config_path"
      pattern: "from cesar\\.config import"
    - from: "cesar/api/server.py"
      to: "cesar/config.py"
      via: "imports load_config and get_api_config_path"
      pattern: "from cesar\\.config import"
---

<objective>
Integrate configuration loading into CLI and API, enabling config file defaults with CLI argument overrides.

Purpose: Users can set preferences in config files while retaining ability to override via CLI flags.
Output: CLI and API both load config at startup with proper error handling.
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-configuration-system/09-CONTEXT.md
@.planning/phases/09-configuration-system/09-RESEARCH.md
@.planning/phases/09-configuration-system/09-01-SUMMARY.md
@cesar/cli.py
@cesar/api/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate config loading into CLI with override support</name>
  <files>cesar/cli.py</files>
  <action>
Modify cesar/cli.py to load config at startup:

1. **Add imports** at top:
   ```python
   from cesar.config import (
       CesarConfig,
       ConfigError,
       load_config,
       get_cli_config_path,
   )
   ```

2. **Load config in cli() group function**:
   - Call `load_config(get_cli_config_path())` in the cli() function
   - Store config in click context: `ctx.ensure_object(dict)['config'] = config`
   - Wrap in try/except ConfigError, print error with console.print("[red]...") and sys.exit(1)
   - Add `@click.pass_context` decorator to cli() function

3. **Access config in transcribe command**:
   - Add `@click.pass_context` decorator to transcribe()
   - Get config from context: `config = ctx.obj.get('config', CesarConfig())`

4. **Note for future phases**:
   The diarize config value will be used in Phase 12 when --diarize flag is added.
   For now, config is loaded and available but no new CLI flags are added (they don't exist yet).
   The plumbing is in place for Phase 12 to use.

5. **First-run informational message** (not blocking):
   - In cli() function, after loading config, check if config file exists
   - If not exists and not quiet mode, print info message:
     `[dim]Config: ~/.config/cesar/config.toml not found (using defaults)[/dim]`
   - This is informational only, not a blocking prompt
  </action>
  <verify>
    - `cesar --help` works (doesn't crash)
    - `cesar transcribe --help` works
    - Create invalid config at ~/.config/cesar/config.toml with `diarize = "oops"`, verify cesar shows error and exits
    - Remove test config file after verification
  </verify>
  <done>
    - CLI loads config on startup
    - Invalid config shows clear error and exits
    - Missing config file uses defaults silently (with dim info message)
    - Config object available to commands via context
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate config loading into API server</name>
  <files>cesar/api/server.py</files>
  <action>
Modify cesar/api/server.py to load config at startup:

1. **Add imports**:
   ```python
   from cesar.config import (
       CesarConfig,
       ConfigError,
       load_config,
       get_api_config_path,
   )
   ```

2. **Load config in lifespan**:
   - At the start of the lifespan() function (before db_path), load config:
     ```python
     config_path = get_api_config_path()
     try:
         config = load_config(config_path)
         logger.info(f"Loaded config from {config_path}")
     except ConfigError as e:
         logger.error(f"Config error: {e}")
         raise  # Let server fail to start on invalid config
     ```
   - If config file doesn't exist, log at debug level: "No config file found, using defaults"
   - Store config in app.state: `app.state.config = config`

3. **Handle missing vs invalid config**:
   - Missing config file: Use defaults, log debug message, continue startup
   - Invalid config file: Raise ConfigError, server fails to start (fail fast per CONTEXT.md)

4. **Note for future phases**:
   The config.diarize value will be used in Phase 13 when API diarize parameter is added.
   For now, config is loaded and stored in app.state for future use.
  </action>
  <verify>
    - `cesar serve --help` works
    - Start server briefly with `timeout 3 cesar serve` (should start without error)
    - Create invalid config.toml in current dir with `min_speakers = -5`, verify server fails to start with clear error
    - Remove test config file after verification
  </verify>
  <done>
    - API loads config on startup (from current directory)
    - Invalid config prevents server from starting with clear error
    - Missing config file uses defaults silently
    - Config object stored in app.state for endpoint access
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for config loading</name>
  <files>tests/test_cli.py, tests/test_server.py</files>
  <action>
Add tests to verify config integration:

**In tests/test_cli.py** (add new test class or extend existing):
- test_cli_runs_without_config: CLI runs when no config file exists
- test_cli_fails_on_invalid_config: CLI exits with error on invalid config

**In tests/test_server.py** (add new test class or extend existing):
- test_server_starts_without_config: Health endpoint works when no config file
- test_server_fails_on_invalid_config: Server fails to start with invalid config

Use tempfile and environment manipulation to test with/without config files.
Mock or use subprocess for CLI tests. Use TestClient for server tests.
  </action>
  <verify>
    - `python -m pytest tests/test_cli.py -v -k config` passes
    - `python -m pytest tests/test_server.py -v -k config` passes
  </verify>
  <done>
    - CLI config loading tested (both missing and invalid cases)
    - API config loading tested (both missing and invalid cases)
    - Tests use proper isolation (temp files, not system config)
  </done>
</task>

</tasks>

<verification>
- CLI works: `cesar --help`, `cesar transcribe --help`
- API works: `cesar serve --help`
- Config error handling: Create invalid config, verify clear error messages
- All tests pass: `python -m pytest tests/ -v -k config`
</verification>

<success_criteria>
- CLI loads ~/.config/cesar/config.toml on startup
- API loads ./config.toml on startup
- Invalid configs cause clear error messages and fail fast
- Missing configs use defaults without error
- Config plumbing in place for Phase 12 (CLI diarize flag) and Phase 13 (API diarize param)
</success_criteria>

<output>
After completion, create `.planning/phases/09-configuration-system/09-02-SUMMARY.md`
</output>
