---
phase: 13-api-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cesar/api/models.py
  - cesar/api/database.py
  - cesar/api/repository.py
  - tests/test_models.py
autonomous: true

must_haves:
  truths:
    - "Job model accepts diarization parameters"
    - "Job model tracks diarization progress and results"
    - "Database persists all diarization fields"
    - "Repository can CRUD jobs with diarization fields"
  artifacts:
    - path: "cesar/api/models.py"
      provides: "Extended Job model with diarization fields"
      contains: "PARTIAL"
    - path: "cesar/api/database.py"
      provides: "Schema with diarization columns"
      contains: "diarize"
    - path: "cesar/api/repository.py"
      provides: "Updated CRUD for diarization fields"
      contains: "speaker_count"
  key_links:
    - from: "cesar/api/repository.py"
      to: "cesar/api/models.py"
      via: "Job model with new fields"
      pattern: "speaker_count"
    - from: "cesar/api/repository.py"
      to: "cesar/api/database.py"
      via: "SQL columns match model fields"
      pattern: "diarize.*diarized.*speaker_count"
---

<objective>
Extend API data models and database schema to support diarization parameters, progress tracking, and partial failure states.

Purpose: Foundation layer enabling worker and endpoints to store/retrieve diarization state
Output: Extended Job model, updated database schema, updated repository CRUD
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-api-integration/13-CONTEXT.md
@.planning/phases/13-api-integration/13-RESEARCH.md
@cesar/api/models.py
@cesar/api/database.py
@cesar/api/repository.py
@cesar/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Job model with diarization fields</name>
  <files>cesar/api/models.py</files>
  <action>
Extend the Job model and JobStatus enum for diarization support:

1. Add PARTIAL to JobStatus enum:
   - PARTIAL = "partial" (transcription OK, diarization failed)
   - Update docstring to document the new flow

2. Add diarization request parameters to Job:
   - diarize: bool = True (matches CLI default)
   - min_speakers: Optional[int] = None
   - max_speakers: Optional[int] = None

3. Add progress tracking fields:
   - progress: Optional[int] = Field(default=None, ge=0, le=100) for overall progress
   - progress_phase: Optional[str] = None (downloading, transcribing, diarizing, formatting)
   - progress_phase_pct: Optional[int] = Field(default=None, ge=0, le=100) for phase progress

4. Add result fields:
   - speaker_count: Optional[int] = Field(default=None, ge=0)
   - diarized: Optional[bool] = None (explicit flag for fallback detection)

5. Add error fields:
   - diarization_error: Optional[str] = None
   - diarization_error_code: Optional[str] = None (hf_token_required, hf_token_invalid, diarization_failed)

6. Add model_validator for speaker range validation:
   - Ensure min_speakers <= max_speakers when both set
   - Raise ValueError with clear message

Use existing Pydantic patterns from the file (ConfigDict, Field, field_validator).
  </action>
  <verify>python -c "from cesar.api.models import Job, JobStatus; j = Job(audio_path='/test', diarize=True, min_speakers=2, max_speakers=4); print(f'PARTIAL={JobStatus.PARTIAL.value}, diarize={j.diarize}, speakers={j.min_speakers}-{j.max_speakers}')"</verify>
  <done>Job model has diarize, min/max_speakers, progress fields, speaker_count, diarized flag, diarization_error fields, and PARTIAL status</done>
</task>

<task type="auto">
  <name>Task 2: Update database schema with diarization columns</name>
  <files>cesar/api/database.py</files>
  <action>
Add new columns to the jobs table schema for diarization support:

1. Update SCHEMA constant to add columns after download_progress:
   - diarize INTEGER DEFAULT 1 (SQLite boolean, default true)
   - min_speakers INTEGER (nullable)
   - max_speakers INTEGER (nullable)
   - progress INTEGER CHECK(progress >= 0 AND progress <= 100)
   - progress_phase TEXT (nullable)
   - progress_phase_pct INTEGER CHECK(progress_phase_pct >= 0 AND progress_phase_pct <= 100)
   - speaker_count INTEGER CHECK(speaker_count >= 0)
   - diarized INTEGER (SQLite boolean, nullable)
   - diarization_error TEXT (nullable)
   - diarization_error_code TEXT (nullable)

2. Add index for partial status queries:
   - CREATE INDEX IF NOT EXISTS idx_jobs_diarize ON jobs(diarize);

Note: Using CREATE TABLE IF NOT EXISTS means existing DBs won't get new columns.
For development, this is acceptable. Production would need migration.
The columns must match the order expected by _row_to_job in repository.py.
  </action>
  <verify>python -c "import asyncio; from cesar.api.database import SCHEMA; print('diarize' in SCHEMA and 'speaker_count' in SCHEMA and 'diarization_error' in SCHEMA)"</verify>
  <done>SCHEMA includes all diarization columns with appropriate constraints</done>
</task>

<task type="auto">
  <name>Task 3: Update repository for diarization fields</name>
  <files>cesar/api/repository.py, tests/test_models.py</files>
  <action>
Update JobRepository to handle new diarization fields:

1. Update create() method:
   - Add diarize, min_speakers, max_speakers to INSERT
   - Add progress, progress_phase, progress_phase_pct
   - Add speaker_count, diarized, diarization_error, diarization_error_code
   - Convert booleans to integers for SQLite (1/0)

2. Update update() method:
   - Add all new fields to UPDATE SET clause
   - Include diarize (in case of retry), speaker_count, diarized
   - Include diarization_error, diarization_error_code for partial failures
   - Include all progress fields

3. Update _row_to_job() method:
   - Map new column indices to Job fields
   - Convert SQLite integers back to booleans for diarize/diarized
   - Handle None values appropriately

4. Add tests in tests/test_models.py:
   - Test Job with diarization fields validates correctly
   - Test min_speakers > max_speakers raises ValueError
   - Test PARTIAL status is valid

Column order must match SCHEMA in database.py exactly.
  </action>
  <verify>cd /home/buckleyrobinson/projects/cesar && python -m pytest tests/test_models.py -v -k "diarize or speaker or PARTIAL" --tb=short 2>/dev/null || python -m pytest tests/test_models.py -v --tb=short</verify>
  <done>Repository CRUD handles all diarization fields, tests pass for new model fields</done>
</task>

</tasks>

<verification>
1. Import and create Job with all new fields:
   python -c "from cesar.api.models import Job, JobStatus; j = Job(audio_path='/test', diarize=True, min_speakers=2, max_speakers=4, progress=50, progress_phase='diarizing', speaker_count=3, diarized=True); print('OK')"

2. Verify schema has all columns:
   python -c "from cesar.api.database import SCHEMA; assert 'diarize' in SCHEMA and 'speaker_count' in SCHEMA and 'diarization_error_code' in SCHEMA; print('Schema OK')"

3. Run model tests:
   python -m pytest tests/test_models.py -v --tb=short
</verification>

<success_criteria>
- Job model has all diarization fields from CONTEXT.md decisions
- JobStatus.PARTIAL exists for partial failure state
- Database schema includes all new columns with constraints
- Repository CRUD persists and retrieves diarization fields correctly
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-api-integration/13-01-SUMMARY.md`
</output>
