---
phase: 13-api-integration
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - cesar/api/server.py
  - tests/test_server.py
autonomous: true

must_haves:
  truths:
    - "User can enable diarization via API parameter"
    - "API accepts diarize as boolean or object"
    - "API validates speaker counts at request time"
    - "Retry endpoint re-queues partial failures"
    - "Job status includes progress phase"
  artifacts:
    - path: "cesar/api/server.py"
      provides: "Updated endpoints with diarization support"
      contains: "DiarizeOptions"
    - path: "tests/test_server.py"
      provides: "Server diarization tests"
      contains: "diarize"
  key_links:
    - from: "cesar/api/server.py"
      to: "cesar/api/models.py"
      via: "Job with diarization fields"
      pattern: "diarize.*min_speakers.*max_speakers"
    - from: "cesar/api/server.py"
      to: "cesar/api/worker.py"
      via: "Worker receives config for HF token"
      pattern: "BackgroundWorker.*config"
---

<objective>
Update FastAPI endpoints to accept diarization parameters, add retry endpoint for partial failures, and pass config to worker.

Purpose: API consumers can enable diarization, monitor progress, and retry failed diarization
Output: Updated transcription endpoints, retry endpoint, server tests
</objective>

<execution_context>
@/home/buckleyrobinson/.claude/get-shit-done/workflows/execute-plan.md
@/home/buckleyrobinson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-api-integration/13-CONTEXT.md
@.planning/phases/13-api-integration/13-RESEARCH.md
@.planning/phases/13-api-integration/13-01-SUMMARY.md
@cesar/api/server.py
@cesar/api/models.py
@cesar/api/worker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DiarizeOptions model and update request models</name>
  <files>cesar/api/server.py</files>
  <action>
Add request models for diarization parameter:

1. Add DiarizeOptions Pydantic model:
   ```python
   class DiarizeOptions(BaseModel):
       """Diarization options when using object form."""
       enabled: bool = True
       min_speakers: Optional[int] = Field(default=None, ge=1)
       max_speakers: Optional[int] = Field(default=None, ge=1)

       @model_validator(mode='after')
       def validate_speaker_range(self) -> 'DiarizeOptions':
           if (self.min_speakers is not None and
               self.max_speakers is not None and
               self.min_speakers > self.max_speakers):
               raise ValueError(
                   f"min_speakers ({self.min_speakers}) cannot exceed "
                   f"max_speakers ({self.max_speakers})"
               )
           return self
   ```

2. Update TranscribeURLRequest to include diarization:
   - diarize: Union[bool, DiarizeOptions] = True (default enabled per CONTEXT.md)
   - Add helper methods:
     - get_diarize_enabled() -> bool
     - get_speaker_range() -> tuple[Optional[int], Optional[int]]

3. Create TranscribeFileRequest for file uploads:
   - Same diarization fields as TranscribeURLRequest
   - model: str = "base"
   - Note: File upload uses Form() so this needs special handling

4. Import Union, model_validator from typing/pydantic as needed.
  </action>
  <verify>python -c "from cesar.api.server import DiarizeOptions, TranscribeURLRequest; r = TranscribeURLRequest(url='http://test.com', diarize={'enabled': True, 'min_speakers': 2}); print(f'enabled={r.get_diarize_enabled()}, range={r.get_speaker_range()}')"</verify>
  <done>DiarizeOptions and updated request models support bool or object diarize parameter</done>
</task>

<task type="auto">
  <name>Task 2: Update transcription endpoints for diarization</name>
  <files>cesar/api/server.py</files>
  <action>
Update POST /transcribe and POST /transcribe/url endpoints:

1. Update transcribe_from_url endpoint:
   - Extract diarize_enabled from request.get_diarize_enabled()
   - Extract min_speakers, max_speakers from request.get_speaker_range()
   - Create Job with diarize=diarize_enabled, min_speakers, max_speakers
   - Works for both YouTube URLs and regular URLs

2. Update transcribe_file_upload endpoint:
   - Add Form parameters for diarization:
     - diarize: bool = Form(default=True)
     - min_speakers: Optional[int] = Form(default=None)
     - max_speakers: Optional[int] = Form(default=None)
   - Validate min <= max at request time (return 400 if invalid)
   - Create Job with diarization parameters

3. Update lifespan to pass config to worker:
   - BackgroundWorker(repo, config=config)
   - This enables worker to resolve HF token
   - Note: Worker __init__ handles config=None gracefully (from Plan 02)

4. Validation errors should return 400 with clear message:
   - Speaker range validation
   - Invalid diarize format
  </action>
  <verify>python -c "from cesar.api.server import app; print('Endpoints updated OK')"</verify>
  <done>Transcription endpoints accept diarization parameters and pass to Job</done>
</task>

<task type="auto">
  <name>Task 3: Add retry endpoint and server tests</name>
  <files>cesar/api/server.py, tests/test_server.py</files>
  <action>
Add retry endpoint and comprehensive tests:

1. Add POST /jobs/{job_id}/retry endpoint:
   ```python
   @app.post("/jobs/{job_id}/retry", response_model=Job, status_code=status.HTTP_202_ACCEPTED)
   async def retry_diarization(job_id: str = PathParam(...)):
       """Retry diarization on a job with partial failure."""
       job = await app.state.repo.get(job_id)
       if not job:
           raise HTTPException(status_code=404, detail=f"Job not found: {job_id}")

       if job.status != JobStatus.PARTIAL:
           raise HTTPException(
               status_code=400,
               detail=f"Can only retry jobs with status 'partial'. Current: {job.status.value}"
           )

       # Re-queue for retry
       job.status = JobStatus.QUEUED
       job.diarization_error = None
       job.diarization_error_code = None
       job.started_at = None
       job.completed_at = None
       await app.state.repo.update(job)

       return job
   ```

2. Add server tests in tests/test_server.py:

   a. Test diarize parameter as boolean:
      - POST /transcribe/url with diarize=true
      - Verify job created with diarize=True
      - POST /transcribe/url with diarize=false
      - Verify job created with diarize=False

   b. Test diarize parameter as object:
      - POST /transcribe/url with diarize={enabled: true, min_speakers: 2, max_speakers: 5}
      - Verify job.min_speakers=2, job.max_speakers=5

   c. Test speaker range validation:
      - POST /transcribe/url with diarize={enabled: true, min_speakers: 5, max_speakers: 2}
      - Expect 422 validation error

   d. Test file upload with diarization:
      - POST /transcribe with diarize=true form field
      - Verify job created with diarize=True

   e. Test retry endpoint - success:
      - Create job with status=PARTIAL
      - POST /jobs/{id}/retry
      - Verify status changed to QUEUED
      - Verify diarization_error cleared

   f. Test retry endpoint - wrong status:
      - Create job with status=COMPLETED
      - POST /jobs/{id}/retry
      - Expect 400 error

   g. Test retry endpoint - not found:
      - POST /jobs/nonexistent/retry
      - Expect 404 error

Use existing test patterns (TestClient, mock repos, fixtures).
  </action>
  <verify>cd /home/buckleyrobinson/projects/cesar && python -m pytest tests/test_server.py -v -k "diarize or retry" --tb=short</verify>
  <done>Retry endpoint works, all server tests for diarization pass</done>
</task>

</tasks>

<verification>
1. Test request models:
   python -c "from cesar.api.server import TranscribeURLRequest, DiarizeOptions; print(TranscribeURLRequest(url='http://x.com', diarize=True).get_diarize_enabled())"

2. Run server tests:
   python -m pytest tests/test_server.py -v -k "diarize or retry" --tb=short

3. Manual API test (if server running):
   curl -X POST http://localhost:8000/transcribe/url \
     -H "Content-Type: application/json" \
     -d '{"url": "http://example.com/audio.mp3", "diarize": {"enabled": true, "min_speakers": 2}}'
</verification>

<success_criteria>
- DiarizeOptions accepts enabled, min_speakers, max_speakers
- TranscribeURLRequest.diarize accepts bool or DiarizeOptions
- Endpoints pass diarization params to Job
- POST /jobs/{id}/retry re-queues PARTIAL jobs
- Worker receives config for HF token
- All server tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-api-integration/13-03-SUMMARY.md`
</output>
